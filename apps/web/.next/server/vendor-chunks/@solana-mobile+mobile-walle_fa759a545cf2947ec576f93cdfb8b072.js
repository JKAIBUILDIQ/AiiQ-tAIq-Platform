"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana-mobile+mobile-walle_fa759a545cf2947ec576f93cdfb8b072";
exports.ids = ["vendor-chunks/@solana-mobile+mobile-walle_fa759a545cf2947ec576f93cdfb8b072"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@solana-mobile+mobile-walle_fa759a545cf2947ec576f93cdfb8b072/node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js":
/*!*************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@solana-mobile+mobile-walle_fa759a545cf2947ec576f93cdfb8b072/node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js ***!
  \*************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaCloneAuthorization: () => (/* binding */ SolanaCloneAuthorization),\n/* harmony export */   SolanaMobileWalletAdapterError: () => (/* binding */ SolanaMobileWalletAdapterError),\n/* harmony export */   SolanaMobileWalletAdapterErrorCode: () => (/* binding */ SolanaMobileWalletAdapterErrorCode),\n/* harmony export */   SolanaMobileWalletAdapterProtocolError: () => (/* binding */ SolanaMobileWalletAdapterProtocolError),\n/* harmony export */   SolanaMobileWalletAdapterProtocolErrorCode: () => (/* binding */ SolanaMobileWalletAdapterProtocolErrorCode),\n/* harmony export */   SolanaSignInWithSolana: () => (/* binding */ SolanaSignInWithSolana),\n/* harmony export */   SolanaSignTransactions: () => (/* binding */ SolanaSignTransactions),\n/* harmony export */   startRemoteScenario: () => (/* binding */ startRemoteScenario),\n/* harmony export */   transact: () => (/* binding */ transact)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/wallet-standard-util */ \"(ssr)/../../node_modules/.pnpm/@solana+wallet-standard-util@1.1.2/node_modules/@solana/wallet-standard-util/lib/esm/signIn.js\");\n\n\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaMobileWalletAdapterErrorCode = {\n    ERROR_ASSOCIATION_PORT_OUT_OF_RANGE: 'ERROR_ASSOCIATION_PORT_OUT_OF_RANGE',\n    ERROR_REFLECTOR_ID_OUT_OF_RANGE: 'ERROR_REFLECTOR_ID_OUT_OF_RANGE',\n    ERROR_FORBIDDEN_WALLET_BASE_URL: 'ERROR_FORBIDDEN_WALLET_BASE_URL',\n    ERROR_SECURE_CONTEXT_REQUIRED: 'ERROR_SECURE_CONTEXT_REQUIRED',\n    ERROR_SESSION_CLOSED: 'ERROR_SESSION_CLOSED',\n    ERROR_SESSION_TIMEOUT: 'ERROR_SESSION_TIMEOUT',\n    ERROR_WALLET_NOT_FOUND: 'ERROR_WALLET_NOT_FOUND',\n    ERROR_INVALID_PROTOCOL_VERSION: 'ERROR_INVALID_PROTOCOL_VERSION',\n    ERROR_BROWSER_NOT_SUPPORTED: 'ERROR_BROWSER_NOT_SUPPORTED',\n};\nclass SolanaMobileWalletAdapterError extends Error {\n    constructor(...args) {\n        const [code, message, data] = args;\n        super(message);\n        this.code = code;\n        this.data = data;\n        this.name = 'SolanaMobileWalletAdapterError';\n    }\n}\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaMobileWalletAdapterProtocolErrorCode = {\n    // Keep these in sync with `mobilewalletadapter/common/ProtocolContract.java`.\n    ERROR_AUTHORIZATION_FAILED: -1,\n    ERROR_INVALID_PAYLOADS: -2,\n    ERROR_NOT_SIGNED: -3,\n    ERROR_NOT_SUBMITTED: -4,\n    ERROR_TOO_MANY_PAYLOADS: -5,\n    ERROR_ATTEST_ORIGIN_ANDROID: -100,\n};\nclass SolanaMobileWalletAdapterProtocolError extends Error {\n    constructor(...args) {\n        const [jsonRpcMessageId, code, message, data] = args;\n        super(message);\n        this.code = code;\n        this.data = data;\n        this.jsonRpcMessageId = jsonRpcMessageId;\n        this.name = 'SolanaMobileWalletAdapterProtocolError';\n    }\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nfunction encode(input) {\n    return window.btoa(input);\n}\nfunction fromUint8Array(byteArray, urlsafe) {\n    const base64 = window.btoa(String.fromCharCode.call(null, ...byteArray));\n    if (urlsafe) {\n        return base64\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_')\n            .replace(/=+$/, '');\n    }\n    else\n        return base64;\n}\nfunction toUint8Array(base64EncodedByteArray) {\n    return new Uint8Array(window\n        .atob(base64EncodedByteArray)\n        .split('')\n        .map((c) => c.charCodeAt(0)));\n}\n\nfunction createHelloReq(ecdhPublicKey, associationKeypairPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const publicKeyBuffer = yield crypto.subtle.exportKey('raw', ecdhPublicKey);\n        const signatureBuffer = yield crypto.subtle.sign({ hash: 'SHA-256', name: 'ECDSA' }, associationKeypairPrivateKey, publicKeyBuffer);\n        const response = new Uint8Array(publicKeyBuffer.byteLength + signatureBuffer.byteLength);\n        response.set(new Uint8Array(publicKeyBuffer), 0);\n        response.set(new Uint8Array(signatureBuffer), publicKeyBuffer.byteLength);\n        return response;\n    });\n}\n\nfunction createSIWSMessage(payload) {\n    return (0,_solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_0__.createSignInMessageText)(payload);\n}\nfunction createSIWSMessageBase64(payload) {\n    return encode(createSIWSMessage(payload));\n}\n\n// optional features\nconst SolanaSignTransactions = 'solana:signTransactions';\nconst SolanaCloneAuthorization = 'solana:cloneAuthorization';\nconst SolanaSignInWithSolana = 'solana:signInWithSolana';\n\n/**\n * Creates a {@link MobileWallet} proxy that handles backwards compatibility and API to RPC conversion.\n *\n * @param protocolVersion the protocol version in use for this session/request\n * @param protocolRequestHandler callback function that handles sending the RPC request to the wallet endpoint.\n * @returns a {@link MobileWallet} proxy\n */\nfunction createMobileWalletProxy(protocolVersion, protocolRequestHandler) {\n    return new Proxy({}, {\n        get(target, p) {\n            // Wrapping a Proxy in a promise results in the Proxy being asked for a 'then' property so must \n            // return null if 'then' is called on this proxy to let the 'resolve()' call know this is not a promise.\n            // see: https://stackoverflow.com/a/53890904\n            //@ts-ignore\n            if (p === 'then') {\n                return null;\n            }\n            if (target[p] == null) {\n                target[p] = function (inputParams) {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        const { method, params } = handleMobileWalletRequest(p, inputParams, protocolVersion);\n                        const result = yield protocolRequestHandler(method, params);\n                        // if the request tried to sign in but the wallet did not return a sign in result, fallback on message signing\n                        if (method === 'authorize' && params.sign_in_payload && !result.sign_in_result) {\n                            result['sign_in_result'] = yield signInFallback(params.sign_in_payload, result, protocolRequestHandler);\n                        }\n                        return handleMobileWalletResponse(p, result, protocolVersion);\n                    });\n                };\n            }\n            return target[p];\n        },\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n    });\n}\n/**\n * Handles all {@link MobileWallet} API requests and determines the correct MWA RPC method and params to call.\n * This handles backwards compatibility, based on the provided @protocolVersion.\n *\n * @param methodName the name of {@link MobileWallet} method that was called\n * @param methodParams the parameters that were passed to the method\n * @param protocolVersion the protocol version in use for this session/request\n * @returns the RPC request method and params that should be sent to the wallet endpoint\n */\nfunction handleMobileWalletRequest(methodName, methodParams, protocolVersion) {\n    let params = methodParams;\n    let method = methodName\n        .toString()\n        .replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`)\n        .toLowerCase();\n    switch (methodName) {\n        case 'authorize': {\n            let { chain } = params;\n            if (protocolVersion === 'legacy') {\n                switch (chain) {\n                    case 'solana:testnet': {\n                        chain = 'testnet';\n                        break;\n                    }\n                    case 'solana:devnet': {\n                        chain = 'devnet';\n                        break;\n                    }\n                    case 'solana:mainnet': {\n                        chain = 'mainnet-beta';\n                        break;\n                    }\n                    default: {\n                        chain = params.cluster;\n                    }\n                }\n                params.cluster = chain;\n            }\n            else {\n                switch (chain) {\n                    case 'testnet':\n                    case 'devnet': {\n                        chain = `solana:${chain}`;\n                        break;\n                    }\n                    case 'mainnet-beta': {\n                        chain = 'solana:mainnet';\n                        break;\n                    }\n                }\n                params.chain = chain;\n            }\n        }\n        case 'reauthorize': {\n            const { auth_token, identity } = params;\n            if (auth_token) {\n                switch (protocolVersion) {\n                    case 'legacy': {\n                        method = 'reauthorize';\n                        params = { auth_token: auth_token, identity: identity };\n                        break;\n                    }\n                    default: {\n                        method = 'authorize';\n                        break;\n                    }\n                }\n            }\n            break;\n        }\n    }\n    return { method, params };\n}\n/**\n * Handles all {@link MobileWallet} API responses and modifies the response for backwards compatibility, if needed\n *\n * @param method the {@link MobileWallet} method that was called\n * @param response the original response that was returned by the method call\n * @param protocolVersion the protocol version in use for this session/request\n * @returns the possibly modified response\n */\nfunction handleMobileWalletResponse(method, response, protocolVersion) {\n    switch (method) {\n        case 'getCapabilities': {\n            const capabilities = response;\n            switch (protocolVersion) {\n                case 'legacy': {\n                    const features = [SolanaSignTransactions];\n                    if (capabilities.supports_clone_authorization === true) {\n                        features.push(SolanaCloneAuthorization);\n                    }\n                    return Object.assign(Object.assign({}, capabilities), { features: features });\n                }\n                case 'v1': {\n                    return Object.assign(Object.assign({}, capabilities), { supports_sign_and_send_transactions: true, supports_clone_authorization: capabilities.features.includes(SolanaCloneAuthorization) });\n                }\n            }\n        }\n    }\n    return response;\n}\nfunction signInFallback(signInPayload, authorizationResult, protocolRequestHandler) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        const domain = (_a = signInPayload.domain) !== null && _a !== void 0 ? _a : window.location.host;\n        const address = authorizationResult.accounts[0].address;\n        const siwsMessage = createSIWSMessageBase64(Object.assign(Object.assign({}, signInPayload), { domain, address }));\n        const signMessageResult = yield protocolRequestHandler('sign_messages', {\n            addresses: [address],\n            payloads: [siwsMessage]\n        });\n        const signInResult = {\n            address: address,\n            signed_message: siwsMessage,\n            signature: signMessageResult.signed_payloads[0].slice(siwsMessage.length)\n        };\n        return signInResult;\n    });\n}\n\nconst SEQUENCE_NUMBER_BYTES = 4;\nfunction createSequenceNumberVector(sequenceNumber) {\n    if (sequenceNumber >= 4294967296) {\n        throw new Error('Outbound sequence number overflow. The maximum sequence number is 32-bytes.');\n    }\n    const byteArray = new ArrayBuffer(SEQUENCE_NUMBER_BYTES);\n    const view = new DataView(byteArray);\n    view.setUint32(0, sequenceNumber, /* littleEndian */ false);\n    return new Uint8Array(byteArray);\n}\n\nconst INITIALIZATION_VECTOR_BYTES = 12;\nconst ENCODED_PUBLIC_KEY_LENGTH_BYTES = 65;\nfunction encryptMessage(plaintext, sequenceNumber, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const sequenceNumberVector = createSequenceNumberVector(sequenceNumber);\n        const initializationVector = new Uint8Array(INITIALIZATION_VECTOR_BYTES);\n        crypto.getRandomValues(initializationVector);\n        const ciphertext = yield crypto.subtle.encrypt(getAlgorithmParams(sequenceNumberVector, initializationVector), sharedSecret, new TextEncoder().encode(plaintext));\n        const response = new Uint8Array(sequenceNumberVector.byteLength + initializationVector.byteLength + ciphertext.byteLength);\n        response.set(new Uint8Array(sequenceNumberVector), 0);\n        response.set(new Uint8Array(initializationVector), sequenceNumberVector.byteLength);\n        response.set(new Uint8Array(ciphertext), sequenceNumberVector.byteLength + initializationVector.byteLength);\n        return response;\n    });\n}\nfunction decryptMessage(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const sequenceNumberVector = message.slice(0, SEQUENCE_NUMBER_BYTES);\n        const initializationVector = message.slice(SEQUENCE_NUMBER_BYTES, SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES);\n        const ciphertext = message.slice(SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES);\n        const plaintextBuffer = yield crypto.subtle.decrypt(getAlgorithmParams(sequenceNumberVector, initializationVector), sharedSecret, ciphertext);\n        const plaintext = getUtf8Decoder().decode(plaintextBuffer);\n        return plaintext;\n    });\n}\nfunction getAlgorithmParams(sequenceNumber, initializationVector) {\n    return {\n        additionalData: sequenceNumber,\n        iv: initializationVector,\n        name: 'AES-GCM',\n        tagLength: 128, // 16 byte tag => 128 bits\n    };\n}\nlet _utf8Decoder;\nfunction getUtf8Decoder() {\n    if (_utf8Decoder === undefined) {\n        _utf8Decoder = new TextDecoder('utf-8');\n    }\n    return _utf8Decoder;\n}\n\nfunction generateAssociationKeypair() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield crypto.subtle.generateKey({\n            name: 'ECDSA',\n            namedCurve: 'P-256',\n        }, false /* extractable */, ['sign'] /* keyUsages */);\n    });\n}\n\nfunction generateECDHKeypair() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield crypto.subtle.generateKey({\n            name: 'ECDH',\n            namedCurve: 'P-256',\n        }, false /* extractable */, ['deriveKey', 'deriveBits'] /* keyUsages */);\n    });\n}\n\n// https://stackoverflow.com/a/9458996/802047\nfunction arrayBufferToBase64String(buffer) {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n    const len = bytes.byteLength;\n    for (let ii = 0; ii < len; ii++) {\n        binary += String.fromCharCode(bytes[ii]);\n    }\n    return window.btoa(binary);\n}\n\nfunction getRandomAssociationPort() {\n    return assertAssociationPort(49152 + Math.floor(Math.random() * (65535 - 49152 + 1)));\n}\nfunction assertAssociationPort(port) {\n    if (port < 49152 || port > 65535) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_ASSOCIATION_PORT_OUT_OF_RANGE, `Association port number must be between 49152 and 65535. ${port} given.`, { port });\n    }\n    return port;\n}\n\nfunction getStringWithURLUnsafeCharactersReplaced(unsafeBase64EncodedString) {\n    return unsafeBase64EncodedString.replace(/[/+=]/g, (m) => ({\n        '/': '_',\n        '+': '-',\n        '=': '.',\n    }[m]));\n}\n\nconst INTENT_NAME = 'solana-wallet';\nfunction getPathParts(pathString) {\n    return (pathString\n        // Strip leading and trailing slashes\n        .replace(/(^\\/+|\\/+$)/g, '')\n        // Return an array of directories\n        .split('/'));\n}\nfunction getIntentURL(methodPathname, intentUrlBase) {\n    let baseUrl = null;\n    if (intentUrlBase) {\n        try {\n            baseUrl = new URL(intentUrlBase);\n        }\n        catch (_a) { } // eslint-disable-line no-empty\n        if ((baseUrl === null || baseUrl === void 0 ? void 0 : baseUrl.protocol) !== 'https:') {\n            throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, 'Base URLs supplied by wallets must be valid `https` URLs');\n        }\n    }\n    baseUrl || (baseUrl = new URL(`${INTENT_NAME}:/`));\n    const pathname = methodPathname.startsWith('/')\n        ? // Method is an absolute path. Replace it wholesale.\n            methodPathname\n        : // Method is a relative path. Merge it with the existing one.\n            [...getPathParts(baseUrl.pathname), ...getPathParts(methodPathname)].join('/');\n    return new URL(pathname, baseUrl);\n}\nfunction getAssociateAndroidIntentURL(associationPublicKey, putativePort, associationURLBase, protocolVersions = ['v1']) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const associationPort = assertAssociationPort(putativePort);\n        const exportedKey = yield crypto.subtle.exportKey('raw', associationPublicKey);\n        const encodedKey = arrayBufferToBase64String(exportedKey);\n        const url = getIntentURL('v1/associate/local', associationURLBase);\n        url.searchParams.set('association', getStringWithURLUnsafeCharactersReplaced(encodedKey));\n        url.searchParams.set('port', `${associationPort}`);\n        protocolVersions.forEach((version) => {\n            url.searchParams.set('v', version);\n        });\n        return url;\n    });\n}\nfunction getRemoteAssociateAndroidIntentURL(associationPublicKey, hostAuthority, reflectorId, associationURLBase, protocolVersions = ['v1']) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const exportedKey = yield crypto.subtle.exportKey('raw', associationPublicKey);\n        const encodedKey = arrayBufferToBase64String(exportedKey);\n        const url = getIntentURL('v1/associate/remote', associationURLBase);\n        url.searchParams.set('association', getStringWithURLUnsafeCharactersReplaced(encodedKey));\n        url.searchParams.set('reflector', `${hostAuthority}`);\n        url.searchParams.set('id', `${fromUint8Array(reflectorId, true)}`);\n        protocolVersions.forEach((version) => {\n            url.searchParams.set('v', version);\n        });\n        return url;\n    });\n}\n\nfunction encryptJsonRpcMessage(jsonRpcMessage, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const plaintext = JSON.stringify(jsonRpcMessage);\n        const sequenceNumber = jsonRpcMessage.id;\n        return encryptMessage(plaintext, sequenceNumber, sharedSecret);\n    });\n}\nfunction decryptJsonRpcMessage(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const plaintext = yield decryptMessage(message, sharedSecret);\n        const jsonRpcMessage = JSON.parse(plaintext);\n        if (Object.hasOwnProperty.call(jsonRpcMessage, 'error')) {\n            throw new SolanaMobileWalletAdapterProtocolError(jsonRpcMessage.id, jsonRpcMessage.error.code, jsonRpcMessage.error.message);\n        }\n        return jsonRpcMessage;\n    });\n}\n\nfunction parseHelloRsp(payloadBuffer, // The X9.62-encoded wallet endpoint ephemeral ECDH public keypoint.\nassociationPublicKey, ecdhPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const [associationPublicKeyBuffer, walletPublicKey] = yield Promise.all([\n            crypto.subtle.exportKey('raw', associationPublicKey),\n            crypto.subtle.importKey('raw', payloadBuffer.slice(0, ENCODED_PUBLIC_KEY_LENGTH_BYTES), { name: 'ECDH', namedCurve: 'P-256' }, false /* extractable */, [] /* keyUsages */),\n        ]);\n        const sharedSecret = yield crypto.subtle.deriveBits({ name: 'ECDH', public: walletPublicKey }, ecdhPrivateKey, 256);\n        const ecdhSecretKey = yield crypto.subtle.importKey('raw', sharedSecret, 'HKDF', false /* extractable */, ['deriveKey'] /* keyUsages */);\n        const aesKeyMaterialVal = yield crypto.subtle.deriveKey({\n            name: 'HKDF',\n            hash: 'SHA-256',\n            salt: new Uint8Array(associationPublicKeyBuffer),\n            info: new Uint8Array(),\n        }, ecdhSecretKey, { name: 'AES-GCM', length: 128 }, false /* extractable */, ['encrypt', 'decrypt']);\n        return aesKeyMaterialVal;\n    });\n}\n\nfunction parseSessionProps(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const plaintext = yield decryptMessage(message, sharedSecret);\n        const jsonProperties = JSON.parse(plaintext);\n        let protocolVersion = 'legacy';\n        if (Object.hasOwnProperty.call(jsonProperties, 'v')) {\n            switch (jsonProperties.v) {\n                case 1:\n                case '1':\n                case 'v1':\n                    protocolVersion = 'v1';\n                    break;\n                case 'legacy':\n                    protocolVersion = 'legacy';\n                    break;\n                default:\n                    throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_INVALID_PROTOCOL_VERSION, `Unknown/unsupported protocol version: ${jsonProperties.v}`);\n            }\n        }\n        return ({\n            protocol_version: protocolVersion\n        });\n    });\n}\n\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst Browser = {\n    Firefox: 0,\n    Other: 1,\n};\nfunction assertUnreachable(x) {\n    return x;\n}\nfunction getBrowser() {\n    return navigator.userAgent.indexOf('Firefox/') !== -1 ? Browser.Firefox : Browser.Other;\n}\nfunction getDetectionPromise() {\n    // Chrome and others silently fail if a custom protocol is not supported.\n    // For these, we wait to see if the browser is navigated away from in\n    // a reasonable amount of time (ie. the native wallet opened).\n    return new Promise((resolve, reject) => {\n        function cleanup() {\n            clearTimeout(timeoutId);\n            window.removeEventListener('blur', handleBlur);\n        }\n        function handleBlur() {\n            cleanup();\n            resolve();\n        }\n        window.addEventListener('blur', handleBlur);\n        const timeoutId = setTimeout(() => {\n            cleanup();\n            reject();\n        }, 3000);\n    });\n}\nlet _frame = null;\nfunction launchUrlThroughHiddenFrame(url) {\n    if (_frame == null) {\n        _frame = document.createElement('iframe');\n        _frame.style.display = 'none';\n        document.body.appendChild(_frame);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    _frame.contentWindow.location.href = url.toString();\n}\nfunction launchAssociation(associationUrl) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (associationUrl.protocol === 'https:') {\n            // The association URL is an Android 'App Link' or iOS 'Universal Link'.\n            // These are regular web URLs that are designed to launch an app if it\n            // is installed or load the actual target webpage if not.\n            window.location.assign(associationUrl);\n        }\n        else {\n            // The association URL has a custom protocol (eg. `solana-wallet:`)\n            try {\n                const browser = getBrowser();\n                switch (browser) {\n                    case Browser.Firefox:\n                        // If a custom protocol is not supported in Firefox, it throws.\n                        launchUrlThroughHiddenFrame(associationUrl);\n                        // If we reached this line, it's supported.\n                        break;\n                    case Browser.Other: {\n                        const detectionPromise = getDetectionPromise();\n                        window.location.assign(associationUrl);\n                        yield detectionPromise;\n                        break;\n                    }\n                    default:\n                        assertUnreachable(browser);\n                }\n            }\n            catch (e) {\n                throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_WALLET_NOT_FOUND, 'Found no installed wallet that supports the mobile wallet protocol.');\n            }\n        }\n    });\n}\nfunction startSession(associationPublicKey, associationURLBase) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const randomAssociationPort = getRandomAssociationPort();\n        const associationUrl = yield getAssociateAndroidIntentURL(associationPublicKey, randomAssociationPort, associationURLBase);\n        yield launchAssociation(associationUrl);\n        return randomAssociationPort;\n    });\n}\n\nconst WEBSOCKET_CONNECTION_CONFIG = {\n    /**\n     * 300 milliseconds is a generally accepted threshold for what someone\n     * would consider an acceptable response time for a user interface\n     * after having performed a low-attention tapping task. We set the initial\n     * interval at which we wait for the wallet to set up the websocket at\n     * half this, as per the Nyquist frequency, with a progressive backoff\n     * sequence from there. The total wait time is 30s, which allows for the\n     * user to be presented with a disambiguation dialog, select a wallet, and\n     * for the wallet app to subsequently start.\n     */\n    retryDelayScheduleMs: [150, 150, 200, 500, 500, 750, 750, 1000],\n    timeoutMs: 30000,\n};\nconst WEBSOCKET_PROTOCOL_BINARY = 'com.solana.mobilewalletadapter.v1';\nconst WEBSOCKET_PROTOCOL_BASE64 = 'com.solana.mobilewalletadapter.v1.base64';\nfunction assertSecureContext() {\n    if (typeof window === 'undefined' || window.isSecureContext !== true) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SECURE_CONTEXT_REQUIRED, 'The mobile wallet adapter protocol must be used in a secure context (`https`).');\n    }\n}\nfunction assertSecureEndpointSpecificURI(walletUriBase) {\n    let url;\n    try {\n        url = new URL(walletUriBase);\n    }\n    catch (_a) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, 'Invalid base URL supplied by wallet');\n    }\n    if (url.protocol !== 'https:') {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, 'Base URLs supplied by wallets must be valid `https` URLs');\n    }\n}\nfunction getSequenceNumberFromByteArray(byteArray) {\n    const view = new DataView(byteArray);\n    return view.getUint32(0, /* littleEndian */ false);\n}\nfunction decodeVarLong(byteArray) {\n    var bytes = new Uint8Array(byteArray), l = byteArray.byteLength, limit = 10, value = 0, offset = 0, b;\n    do {\n        if (offset >= l || offset > limit)\n            throw new RangeError('Failed to decode varint');\n        b = bytes[offset++];\n        value |= (b & 0x7F) << (7 * offset);\n    } while (b >= 0x80);\n    return { value, offset };\n}\nfunction getReflectorIdFromByteArray(byteArray) {\n    let { value: length, offset } = decodeVarLong(byteArray);\n    return new Uint8Array(byteArray.slice(offset, offset + length));\n}\nfunction transact(callback, config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        assertSecureContext();\n        const associationKeypair = yield generateAssociationKeypair();\n        const sessionPort = yield startSession(associationKeypair.publicKey, config === null || config === void 0 ? void 0 : config.baseUri);\n        const websocketURL = `ws://localhost:${sessionPort}/solana-wallet`;\n        let connectionStartTime;\n        const getNextRetryDelayMs = (() => {\n            const schedule = [...WEBSOCKET_CONNECTION_CONFIG.retryDelayScheduleMs];\n            return () => (schedule.length > 1 ? schedule.shift() : schedule[0]);\n        })();\n        let nextJsonRpcMessageId = 1;\n        let lastKnownInboundSequenceNumber = 0;\n        let state = { __type: 'disconnected' };\n        return new Promise((resolve, reject) => {\n            let socket;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const jsonRpcResponsePromises = {};\n            const handleOpen = () => __awaiter(this, void 0, void 0, function* () {\n                if (state.__type !== 'connecting') {\n                    console.warn('Expected adapter state to be `connecting` at the moment the websocket opens. ' +\n                        `Got \\`${state.__type}\\`.`);\n                    return;\n                }\n                socket.removeEventListener('open', handleOpen);\n                // previous versions of this library and walletlib incorrectly implemented the MWA session \n                // establishment protocol for local connections. The dapp is supposed to wait for the \n                // APP_PING message before sending the HELLO_REQ. Instead, the dapp was sending the HELLO_REQ \n                // immediately upon connection to the websocket server regardless of wether or not an \n                // APP_PING was sent by the wallet/websocket server. We must continue to support this behavior \n                // in case the user is using a wallet that has not updated their walletlib implementation. \n                const { associationKeypair } = state;\n                const ecdhKeypair = yield generateECDHKeypair();\n                socket.send(yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey));\n                state = {\n                    __type: 'hello_req_sent',\n                    associationPublicKey: associationKeypair.publicKey,\n                    ecdhPrivateKey: ecdhKeypair.privateKey,\n                };\n            });\n            const handleClose = (evt) => {\n                if (evt.wasClean) {\n                    state = { __type: 'disconnected' };\n                }\n                else {\n                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session dropped unexpectedly (${evt.code}: ${evt.reason}).`, { closeEvent: evt }));\n                }\n                disposeSocket();\n            };\n            const handleError = (_evt) => __awaiter(this, void 0, void 0, function* () {\n                disposeSocket();\n                if (Date.now() - connectionStartTime >= WEBSOCKET_CONNECTION_CONFIG.timeoutMs) {\n                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_TIMEOUT, `Failed to connect to the wallet websocket at ${websocketURL}.`));\n                }\n                else {\n                    yield new Promise((resolve) => {\n                        const retryDelayMs = getNextRetryDelayMs();\n                        retryWaitTimeoutId = window.setTimeout(resolve, retryDelayMs);\n                    });\n                    attemptSocketConnection();\n                }\n            });\n            const handleMessage = (evt) => __awaiter(this, void 0, void 0, function* () {\n                const responseBuffer = yield evt.data.arrayBuffer();\n                switch (state.__type) {\n                    case 'connecting':\n                        if (responseBuffer.byteLength !== 0) {\n                            throw new Error('Encountered unexpected message while connecting');\n                        }\n                        const ecdhKeypair = yield generateECDHKeypair();\n                        socket.send(yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey));\n                        state = {\n                            __type: 'hello_req_sent',\n                            associationPublicKey: associationKeypair.publicKey,\n                            ecdhPrivateKey: ecdhKeypair.privateKey,\n                        };\n                        break;\n                    case 'connected':\n                        try {\n                            const sequenceNumberVector = responseBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                            const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                            if (sequenceNumber !== (lastKnownInboundSequenceNumber + 1)) {\n                                throw new Error('Encrypted message has invalid sequence number');\n                            }\n                            lastKnownInboundSequenceNumber = sequenceNumber;\n                            const jsonRpcMessage = yield decryptJsonRpcMessage(responseBuffer, state.sharedSecret);\n                            const responsePromise = jsonRpcResponsePromises[jsonRpcMessage.id];\n                            delete jsonRpcResponsePromises[jsonRpcMessage.id];\n                            responsePromise.resolve(jsonRpcMessage.result);\n                        }\n                        catch (e) {\n                            if (e instanceof SolanaMobileWalletAdapterProtocolError) {\n                                const responsePromise = jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                delete jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                responsePromise.reject(e);\n                            }\n                            else {\n                                throw e;\n                            }\n                        }\n                        break;\n                    case 'hello_req_sent': {\n                        // if we receive an APP_PING message (empty message), resend the HELLO_REQ (see above)\n                        if (responseBuffer.byteLength === 0) {\n                            const ecdhKeypair = yield generateECDHKeypair();\n                            socket.send(yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey));\n                            state = {\n                                __type: 'hello_req_sent',\n                                associationPublicKey: associationKeypair.publicKey,\n                                ecdhPrivateKey: ecdhKeypair.privateKey,\n                            };\n                            break;\n                        }\n                        const sharedSecret = yield parseHelloRsp(responseBuffer, state.associationPublicKey, state.ecdhPrivateKey);\n                        const sessionPropertiesBuffer = responseBuffer.slice(ENCODED_PUBLIC_KEY_LENGTH_BYTES);\n                        const sessionProperties = sessionPropertiesBuffer.byteLength !== 0\n                            ? yield (() => __awaiter(this, void 0, void 0, function* () {\n                                const sequenceNumberVector = sessionPropertiesBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                if (sequenceNumber !== (lastKnownInboundSequenceNumber + 1)) {\n                                    throw new Error('Encrypted message has invalid sequence number');\n                                }\n                                lastKnownInboundSequenceNumber = sequenceNumber;\n                                return parseSessionProps(sessionPropertiesBuffer, sharedSecret);\n                            }))() : { protocol_version: 'legacy' };\n                        state = { __type: 'connected', sharedSecret, sessionProperties };\n                        const wallet = createMobileWalletProxy(sessionProperties.protocol_version, (method, params) => __awaiter(this, void 0, void 0, function* () {\n                            const id = nextJsonRpcMessageId++;\n                            socket.send(yield encryptJsonRpcMessage({\n                                id,\n                                jsonrpc: '2.0',\n                                method,\n                                params: params !== null && params !== void 0 ? params : {},\n                            }, sharedSecret));\n                            return new Promise((resolve, reject) => {\n                                jsonRpcResponsePromises[id] = {\n                                    resolve(result) {\n                                        switch (method) {\n                                            case 'authorize':\n                                            case 'reauthorize': {\n                                                const { wallet_uri_base } = result;\n                                                if (wallet_uri_base != null) {\n                                                    try {\n                                                        assertSecureEndpointSpecificURI(wallet_uri_base);\n                                                    }\n                                                    catch (e) {\n                                                        reject(e);\n                                                        return;\n                                                    }\n                                                }\n                                                break;\n                                            }\n                                        }\n                                        resolve(result);\n                                    },\n                                    reject,\n                                };\n                            });\n                        }));\n                        try {\n                            resolve(yield callback(wallet));\n                        }\n                        catch (e) {\n                            reject(e);\n                        }\n                        finally {\n                            disposeSocket();\n                            socket.close();\n                        }\n                        break;\n                    }\n                }\n            });\n            let disposeSocket;\n            let retryWaitTimeoutId;\n            const attemptSocketConnection = () => {\n                if (disposeSocket) {\n                    disposeSocket();\n                }\n                state = { __type: 'connecting', associationKeypair };\n                if (connectionStartTime === undefined) {\n                    connectionStartTime = Date.now();\n                }\n                socket = new WebSocket(websocketURL, [WEBSOCKET_PROTOCOL_BINARY]);\n                socket.addEventListener('open', handleOpen);\n                socket.addEventListener('close', handleClose);\n                socket.addEventListener('error', handleError);\n                socket.addEventListener('message', handleMessage);\n                disposeSocket = () => {\n                    window.clearTimeout(retryWaitTimeoutId);\n                    socket.removeEventListener('open', handleOpen);\n                    socket.removeEventListener('close', handleClose);\n                    socket.removeEventListener('error', handleError);\n                    socket.removeEventListener('message', handleMessage);\n                };\n            };\n            attemptSocketConnection();\n        });\n    });\n}\nfunction startRemoteScenario(config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        assertSecureContext();\n        const associationKeypair = yield generateAssociationKeypair();\n        const websocketURL = `wss://${config === null || config === void 0 ? void 0 : config.remoteHostAuthority}/reflect`;\n        let connectionStartTime;\n        const getNextRetryDelayMs = (() => {\n            const schedule = [...WEBSOCKET_CONNECTION_CONFIG.retryDelayScheduleMs];\n            return () => (schedule.length > 1 ? schedule.shift() : schedule[0]);\n        })();\n        let nextJsonRpcMessageId = 1;\n        let lastKnownInboundSequenceNumber = 0;\n        let encoding;\n        let state = { __type: 'disconnected' };\n        let socket;\n        let disposeSocket;\n        let decodeBytes = (evt) => __awaiter(this, void 0, void 0, function* () {\n            if (encoding == 'base64') { // base64 encoding\n                const message = yield evt.data;\n                return toUint8Array(message).buffer;\n            }\n            else {\n                return yield evt.data.arrayBuffer();\n            }\n        });\n        // Reflector Connection Phase\n        // here we connect to the reflector and wait for the REFLECTOR_ID message \n        // so we build the association URL and return that back to the caller\n        const associationUrl = yield new Promise((resolve, reject) => {\n            const handleOpen = () => __awaiter(this, void 0, void 0, function* () {\n                if (state.__type !== 'connecting') {\n                    console.warn('Expected adapter state to be `connecting` at the moment the websocket opens. ' +\n                        `Got \\`${state.__type}\\`.`);\n                    return;\n                }\n                if (socket.protocol.includes(WEBSOCKET_PROTOCOL_BASE64)) {\n                    encoding = 'base64';\n                }\n                else {\n                    encoding = 'binary';\n                }\n                socket.removeEventListener('open', handleOpen);\n            });\n            const handleClose = (evt) => {\n                if (evt.wasClean) {\n                    state = { __type: 'disconnected' };\n                }\n                else {\n                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session dropped unexpectedly (${evt.code}: ${evt.reason}).`, { closeEvent: evt }));\n                }\n                disposeSocket();\n            };\n            const handleError = (_evt) => __awaiter(this, void 0, void 0, function* () {\n                disposeSocket();\n                if (Date.now() - connectionStartTime >= WEBSOCKET_CONNECTION_CONFIG.timeoutMs) {\n                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_TIMEOUT, `Failed to connect to the wallet websocket at ${websocketURL}.`));\n                }\n                else {\n                    yield new Promise((resolve) => {\n                        const retryDelayMs = getNextRetryDelayMs();\n                        retryWaitTimeoutId = window.setTimeout(resolve, retryDelayMs);\n                    });\n                    attemptSocketConnection();\n                }\n            });\n            const handleReflectorIdMessage = (evt) => __awaiter(this, void 0, void 0, function* () {\n                const responseBuffer = yield decodeBytes(evt);\n                if (state.__type === 'connecting') {\n                    if (responseBuffer.byteLength == 0) {\n                        throw new Error('Encountered unexpected message while connecting');\n                    }\n                    const reflectorId = getReflectorIdFromByteArray(responseBuffer);\n                    state = {\n                        __type: 'reflector_id_received',\n                        reflectorId: reflectorId\n                    };\n                    const associationUrl = yield getRemoteAssociateAndroidIntentURL(associationKeypair.publicKey, config.remoteHostAuthority, reflectorId, config === null || config === void 0 ? void 0 : config.baseUri);\n                    socket.removeEventListener('message', handleReflectorIdMessage);\n                    resolve(associationUrl);\n                }\n            });\n            let retryWaitTimeoutId;\n            const attemptSocketConnection = () => {\n                if (disposeSocket) {\n                    disposeSocket();\n                }\n                state = { __type: 'connecting', associationKeypair };\n                if (connectionStartTime === undefined) {\n                    connectionStartTime = Date.now();\n                }\n                socket = new WebSocket(websocketURL, [WEBSOCKET_PROTOCOL_BINARY, WEBSOCKET_PROTOCOL_BASE64]);\n                socket.addEventListener('open', handleOpen);\n                socket.addEventListener('close', handleClose);\n                socket.addEventListener('error', handleError);\n                socket.addEventListener('message', handleReflectorIdMessage);\n                disposeSocket = () => {\n                    window.clearTimeout(retryWaitTimeoutId);\n                    socket.removeEventListener('open', handleOpen);\n                    socket.removeEventListener('close', handleClose);\n                    socket.removeEventListener('error', handleError);\n                    socket.removeEventListener('message', handleReflectorIdMessage);\n                };\n            };\n            attemptSocketConnection();\n        });\n        // Wallet Connection Phase\n        // here we return the association URL (containing the reflector ID) to the caller + \n        // a promise that will resolve the MobileWallet object once the wallet connects.\n        let sessionEstablished = false;\n        let handleClose;\n        return { associationUrl, close: () => {\n                socket.close();\n                handleClose();\n            }, wallet: new Promise((resolve, reject) => {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const jsonRpcResponsePromises = {};\n                const handleMessage = (evt) => __awaiter(this, void 0, void 0, function* () {\n                    const responseBuffer = yield decodeBytes(evt);\n                    switch (state.__type) {\n                        case 'reflector_id_received':\n                            if (responseBuffer.byteLength !== 0) {\n                                throw new Error('Encountered unexpected message while awaiting reflection');\n                            }\n                            const ecdhKeypair = yield generateECDHKeypair();\n                            const binaryMsg = yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey);\n                            if (encoding == 'base64') {\n                                socket.send(fromUint8Array(binaryMsg));\n                            }\n                            else {\n                                socket.send(binaryMsg);\n                            }\n                            state = {\n                                __type: 'hello_req_sent',\n                                associationPublicKey: associationKeypair.publicKey,\n                                ecdhPrivateKey: ecdhKeypair.privateKey,\n                            };\n                            break;\n                        case 'connected':\n                            try {\n                                const sequenceNumberVector = responseBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                if (sequenceNumber !== (lastKnownInboundSequenceNumber + 1)) {\n                                    throw new Error('Encrypted message has invalid sequence number');\n                                }\n                                lastKnownInboundSequenceNumber = sequenceNumber;\n                                const jsonRpcMessage = yield decryptJsonRpcMessage(responseBuffer, state.sharedSecret);\n                                const responsePromise = jsonRpcResponsePromises[jsonRpcMessage.id];\n                                delete jsonRpcResponsePromises[jsonRpcMessage.id];\n                                responsePromise.resolve(jsonRpcMessage.result);\n                            }\n                            catch (e) {\n                                if (e instanceof SolanaMobileWalletAdapterProtocolError) {\n                                    const responsePromise = jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                    delete jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                    responsePromise.reject(e);\n                                }\n                                else {\n                                    throw e;\n                                }\n                            }\n                            break;\n                        case 'hello_req_sent': {\n                            const sharedSecret = yield parseHelloRsp(responseBuffer, state.associationPublicKey, state.ecdhPrivateKey);\n                            const sessionPropertiesBuffer = responseBuffer.slice(ENCODED_PUBLIC_KEY_LENGTH_BYTES);\n                            const sessionProperties = sessionPropertiesBuffer.byteLength !== 0\n                                ? yield (() => __awaiter(this, void 0, void 0, function* () {\n                                    const sequenceNumberVector = sessionPropertiesBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                    const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                    if (sequenceNumber !== (lastKnownInboundSequenceNumber + 1)) {\n                                        throw new Error('Encrypted message has invalid sequence number');\n                                    }\n                                    lastKnownInboundSequenceNumber = sequenceNumber;\n                                    return parseSessionProps(sessionPropertiesBuffer, sharedSecret);\n                                }))() : { protocol_version: 'legacy' };\n                            state = { __type: 'connected', sharedSecret, sessionProperties };\n                            const wallet = createMobileWalletProxy(sessionProperties.protocol_version, (method, params) => __awaiter(this, void 0, void 0, function* () {\n                                const id = nextJsonRpcMessageId++;\n                                const binaryMsg = yield encryptJsonRpcMessage({\n                                    id,\n                                    jsonrpc: '2.0',\n                                    method,\n                                    params: params !== null && params !== void 0 ? params : {},\n                                }, sharedSecret);\n                                if (encoding == 'base64') {\n                                    socket.send(fromUint8Array(binaryMsg));\n                                }\n                                else {\n                                    socket.send(binaryMsg);\n                                }\n                                return new Promise((resolve, reject) => {\n                                    jsonRpcResponsePromises[id] = {\n                                        resolve(result) {\n                                            switch (method) {\n                                                case 'authorize':\n                                                case 'reauthorize': {\n                                                    const { wallet_uri_base } = result;\n                                                    if (wallet_uri_base != null) {\n                                                        try {\n                                                            assertSecureEndpointSpecificURI(wallet_uri_base);\n                                                        }\n                                                        catch (e) {\n                                                            reject(e);\n                                                            return;\n                                                        }\n                                                    }\n                                                    break;\n                                                }\n                                            }\n                                            resolve(result);\n                                        },\n                                        reject,\n                                    };\n                                });\n                            }));\n                            sessionEstablished = true;\n                            try {\n                                resolve(wallet);\n                            }\n                            catch (e) {\n                                reject(e);\n                            }\n                            break;\n                        }\n                    }\n                });\n                socket.addEventListener('message', handleMessage);\n                handleClose = () => {\n                    socket.removeEventListener('message', handleMessage);\n                    disposeSocket();\n                    if (!sessionEstablished) {\n                        reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session was closed before connection.`, { closeEvent: new CloseEvent('socket was closed before connection') }));\n                    }\n                };\n            }) };\n    });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bzb2xhbmEtbW9iaWxlK21vYmlsZS13YWxsZV9mYTc1OWE1NDVjZjI5NDdlYzU3NmY5M2NkZmI4YjA3Mi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvbW9iaWxlLXdhbGxldC1hZGFwdGVyLXByb3RvY29sL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1RTs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGdDQUFnQztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFdBQVcscUZBQXVCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsa0JBQWtCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpTEFBaUwsbUVBQW1FO0FBQ3BQO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsS0FBSztBQUNMOztBQUUyUSIsInNvdXJjZXMiOlsid2VicGFjazovL0BhaWlxLXRhaXEvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac29sYW5hLW1vYmlsZSttb2JpbGUtd2FsbGVfZmE3NTlhNTQ1Y2YyOTQ3ZWM1NzZmOTNjZGZiOGIwNzIvbm9kZV9tb2R1bGVzL0Bzb2xhbmEtbW9iaWxlL21vYmlsZS13YWxsZXQtYWRhcHRlci1wcm90b2NvbC9saWIvZXNtL2luZGV4LmpzPzVjYjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlU2lnbkluTWVzc2FnZVRleHQgfSBmcm9tICdAc29sYW5hL3dhbGxldC1zdGFuZGFyZC11dGlsJztcblxuLy8gVHlwZXNjcmlwdCBgZW51bXNgIHRod2FydCB0cmVlLXNoYWtpbmcuIFNlZSBodHRwczovL2JhcmdzdGVuLm9yZy9qc3RzL2VudW1zL1xuY29uc3QgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZSA9IHtcbiAgICBFUlJPUl9BU1NPQ0lBVElPTl9QT1JUX09VVF9PRl9SQU5HRTogJ0VSUk9SX0FTU09DSUFUSU9OX1BPUlRfT1VUX09GX1JBTkdFJyxcbiAgICBFUlJPUl9SRUZMRUNUT1JfSURfT1VUX09GX1JBTkdFOiAnRVJST1JfUkVGTEVDVE9SX0lEX09VVF9PRl9SQU5HRScsXG4gICAgRVJST1JfRk9SQklEREVOX1dBTExFVF9CQVNFX1VSTDogJ0VSUk9SX0ZPUkJJRERFTl9XQUxMRVRfQkFTRV9VUkwnLFxuICAgIEVSUk9SX1NFQ1VSRV9DT05URVhUX1JFUVVJUkVEOiAnRVJST1JfU0VDVVJFX0NPTlRFWFRfUkVRVUlSRUQnLFxuICAgIEVSUk9SX1NFU1NJT05fQ0xPU0VEOiAnRVJST1JfU0VTU0lPTl9DTE9TRUQnLFxuICAgIEVSUk9SX1NFU1NJT05fVElNRU9VVDogJ0VSUk9SX1NFU1NJT05fVElNRU9VVCcsXG4gICAgRVJST1JfV0FMTEVUX05PVF9GT1VORDogJ0VSUk9SX1dBTExFVF9OT1RfRk9VTkQnLFxuICAgIEVSUk9SX0lOVkFMSURfUFJPVE9DT0xfVkVSU0lPTjogJ0VSUk9SX0lOVkFMSURfUFJPVE9DT0xfVkVSU0lPTicsXG4gICAgRVJST1JfQlJPV1NFUl9OT1RfU1VQUE9SVEVEOiAnRVJST1JfQlJPV1NFUl9OT1RfU1VQUE9SVEVEJyxcbn07XG5jbGFzcyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCBbY29kZSwgbWVzc2FnZSwgZGF0YV0gPSBhcmdzO1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1NvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcic7XG4gICAgfVxufVxuLy8gVHlwZXNjcmlwdCBgZW51bXNgIHRod2FydCB0cmVlLXNoYWtpbmcuIFNlZSBodHRwczovL2JhcmdzdGVuLm9yZy9qc3RzL2VudW1zL1xuY29uc3QgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3JDb2RlID0ge1xuICAgIC8vIEtlZXAgdGhlc2UgaW4gc3luYyB3aXRoIGBtb2JpbGV3YWxsZXRhZGFwdGVyL2NvbW1vbi9Qcm90b2NvbENvbnRyYWN0LmphdmFgLlxuICAgIEVSUk9SX0FVVEhPUklaQVRJT05fRkFJTEVEOiAtMSxcbiAgICBFUlJPUl9JTlZBTElEX1BBWUxPQURTOiAtMixcbiAgICBFUlJPUl9OT1RfU0lHTkVEOiAtMyxcbiAgICBFUlJPUl9OT1RfU1VCTUlUVEVEOiAtNCxcbiAgICBFUlJPUl9UT09fTUFOWV9QQVlMT0FEUzogLTUsXG4gICAgRVJST1JfQVRURVNUX09SSUdJTl9BTkRST0lEOiAtMTAwLFxufTtcbmNsYXNzIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJQcm90b2NvbEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgW2pzb25ScGNNZXNzYWdlSWQsIGNvZGUsIG1lc3NhZ2UsIGRhdGFdID0gYXJncztcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuanNvblJwY01lc3NhZ2VJZCA9IGpzb25ScGNNZXNzYWdlSWQ7XG4gICAgICAgIHRoaXMubmFtZSA9ICdTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvcic7XG4gICAgfVxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cblxuZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gICAgcmV0dXJuIHdpbmRvdy5idG9hKGlucHV0KTtcbn1cbmZ1bmN0aW9uIGZyb21VaW50OEFycmF5KGJ5dGVBcnJheSwgdXJsc2FmZSkge1xuICAgIGNvbnN0IGJhc2U2NCA9IHdpbmRvdy5idG9hKFN0cmluZy5mcm9tQ2hhckNvZGUuY2FsbChudWxsLCAuLi5ieXRlQXJyYXkpKTtcbiAgICBpZiAodXJsc2FmZSkge1xuICAgICAgICByZXR1cm4gYmFzZTY0XG4gICAgICAgICAgICAucmVwbGFjZSgvXFwrL2csICctJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC8vZywgJ18nKVxuICAgICAgICAgICAgLnJlcGxhY2UoLz0rJC8sICcnKTtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gYmFzZTY0O1xufVxuZnVuY3Rpb24gdG9VaW50OEFycmF5KGJhc2U2NEVuY29kZWRCeXRlQXJyYXkpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkod2luZG93XG4gICAgICAgIC5hdG9iKGJhc2U2NEVuY29kZWRCeXRlQXJyYXkpXG4gICAgICAgIC5zcGxpdCgnJylcbiAgICAgICAgLm1hcCgoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhlbGxvUmVxKGVjZGhQdWJsaWNLZXksIGFzc29jaWF0aW9uS2V5cGFpclByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBwdWJsaWNLZXlCdWZmZXIgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmV4cG9ydEtleSgncmF3JywgZWNkaFB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZUJ1ZmZlciA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuc2lnbih7IGhhc2g6ICdTSEEtMjU2JywgbmFtZTogJ0VDRFNBJyB9LCBhc3NvY2lhdGlvbktleXBhaXJQcml2YXRlS2V5LCBwdWJsaWNLZXlCdWZmZXIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBVaW50OEFycmF5KHB1YmxpY0tleUJ1ZmZlci5ieXRlTGVuZ3RoICsgc2lnbmF0dXJlQnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXNwb25zZS5zZXQobmV3IFVpbnQ4QXJyYXkocHVibGljS2V5QnVmZmVyKSwgMCk7XG4gICAgICAgIHJlc3BvbnNlLnNldChuZXcgVWludDhBcnJheShzaWduYXR1cmVCdWZmZXIpLCBwdWJsaWNLZXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU0lXU01lc3NhZ2UocGF5bG9hZCkge1xuICAgIHJldHVybiBjcmVhdGVTaWduSW5NZXNzYWdlVGV4dChwYXlsb2FkKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNJV1NNZXNzYWdlQmFzZTY0KHBheWxvYWQpIHtcbiAgICByZXR1cm4gZW5jb2RlKGNyZWF0ZVNJV1NNZXNzYWdlKHBheWxvYWQpKTtcbn1cblxuLy8gb3B0aW9uYWwgZmVhdHVyZXNcbmNvbnN0IFNvbGFuYVNpZ25UcmFuc2FjdGlvbnMgPSAnc29sYW5hOnNpZ25UcmFuc2FjdGlvbnMnO1xuY29uc3QgU29sYW5hQ2xvbmVBdXRob3JpemF0aW9uID0gJ3NvbGFuYTpjbG9uZUF1dGhvcml6YXRpb24nO1xuY29uc3QgU29sYW5hU2lnbkluV2l0aFNvbGFuYSA9ICdzb2xhbmE6c2lnbkluV2l0aFNvbGFuYSc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBNb2JpbGVXYWxsZXR9IHByb3h5IHRoYXQgaGFuZGxlcyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBhbmQgQVBJIHRvIFJQQyBjb252ZXJzaW9uLlxuICpcbiAqIEBwYXJhbSBwcm90b2NvbFZlcnNpb24gdGhlIHByb3RvY29sIHZlcnNpb24gaW4gdXNlIGZvciB0aGlzIHNlc3Npb24vcmVxdWVzdFxuICogQHBhcmFtIHByb3RvY29sUmVxdWVzdEhhbmRsZXIgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBoYW5kbGVzIHNlbmRpbmcgdGhlIFJQQyByZXF1ZXN0IHRvIHRoZSB3YWxsZXQgZW5kcG9pbnQuXG4gKiBAcmV0dXJucyBhIHtAbGluayBNb2JpbGVXYWxsZXR9IHByb3h5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1vYmlsZVdhbGxldFByb3h5KHByb3RvY29sVmVyc2lvbiwgcHJvdG9jb2xSZXF1ZXN0SGFuZGxlcikge1xuICAgIHJldHVybiBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgZ2V0KHRhcmdldCwgcCkge1xuICAgICAgICAgICAgLy8gV3JhcHBpbmcgYSBQcm94eSBpbiBhIHByb21pc2UgcmVzdWx0cyBpbiB0aGUgUHJveHkgYmVpbmcgYXNrZWQgZm9yIGEgJ3RoZW4nIHByb3BlcnR5IHNvIG11c3QgXG4gICAgICAgICAgICAvLyByZXR1cm4gbnVsbCBpZiAndGhlbicgaXMgY2FsbGVkIG9uIHRoaXMgcHJveHkgdG8gbGV0IHRoZSAncmVzb2x2ZSgpJyBjYWxsIGtub3cgdGhpcyBpcyBub3QgYSBwcm9taXNlLlxuICAgICAgICAgICAgLy8gc2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTM4OTA5MDRcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKHAgPT09ICd0aGVuJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldFtwXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3BdID0gZnVuY3Rpb24gKGlucHV0UGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG1ldGhvZCwgcGFyYW1zIH0gPSBoYW5kbGVNb2JpbGVXYWxsZXRSZXF1ZXN0KHAsIGlucHV0UGFyYW1zLCBwcm90b2NvbFZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgcHJvdG9jb2xSZXF1ZXN0SGFuZGxlcihtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcmVxdWVzdCB0cmllZCB0byBzaWduIGluIGJ1dCB0aGUgd2FsbGV0IGRpZCBub3QgcmV0dXJuIGEgc2lnbiBpbiByZXN1bHQsIGZhbGxiYWNrIG9uIG1lc3NhZ2Ugc2lnbmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ2F1dGhvcml6ZScgJiYgcGFyYW1zLnNpZ25faW5fcGF5bG9hZCAmJiAhcmVzdWx0LnNpZ25faW5fcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0WydzaWduX2luX3Jlc3VsdCddID0geWllbGQgc2lnbkluRmFsbGJhY2socGFyYW1zLnNpZ25faW5fcGF5bG9hZCwgcmVzdWx0LCBwcm90b2NvbFJlcXVlc3RIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVNb2JpbGVXYWxsZXRSZXNwb25zZShwLCByZXN1bHQsIHByb3RvY29sVmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3BdO1xuICAgICAgICB9LFxuICAgICAgICBkZWZpbmVQcm9wZXJ0eSgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZXRlUHJvcGVydHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEhhbmRsZXMgYWxsIHtAbGluayBNb2JpbGVXYWxsZXR9IEFQSSByZXF1ZXN0cyBhbmQgZGV0ZXJtaW5lcyB0aGUgY29ycmVjdCBNV0EgUlBDIG1ldGhvZCBhbmQgcGFyYW1zIHRvIGNhbGwuXG4gKiBUaGlzIGhhbmRsZXMgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBAcHJvdG9jb2xWZXJzaW9uLlxuICpcbiAqIEBwYXJhbSBtZXRob2ROYW1lIHRoZSBuYW1lIG9mIHtAbGluayBNb2JpbGVXYWxsZXR9IG1ldGhvZCB0aGF0IHdhcyBjYWxsZWRcbiAqIEBwYXJhbSBtZXRob2RQYXJhbXMgdGhlIHBhcmFtZXRlcnMgdGhhdCB3ZXJlIHBhc3NlZCB0byB0aGUgbWV0aG9kXG4gKiBAcGFyYW0gcHJvdG9jb2xWZXJzaW9uIHRoZSBwcm90b2NvbCB2ZXJzaW9uIGluIHVzZSBmb3IgdGhpcyBzZXNzaW9uL3JlcXVlc3RcbiAqIEByZXR1cm5zIHRoZSBSUEMgcmVxdWVzdCBtZXRob2QgYW5kIHBhcmFtcyB0aGF0IHNob3VsZCBiZSBzZW50IHRvIHRoZSB3YWxsZXQgZW5kcG9pbnRcbiAqL1xuZnVuY3Rpb24gaGFuZGxlTW9iaWxlV2FsbGV0UmVxdWVzdChtZXRob2ROYW1lLCBtZXRob2RQYXJhbXMsIHByb3RvY29sVmVyc2lvbikge1xuICAgIGxldCBwYXJhbXMgPSBtZXRob2RQYXJhbXM7XG4gICAgbGV0IG1ldGhvZCA9IG1ldGhvZE5hbWVcbiAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgLnJlcGxhY2UoL1tBLVpdL2csIChsZXR0ZXIpID0+IGBfJHtsZXR0ZXIudG9Mb3dlckNhc2UoKX1gKVxuICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgY2FzZSAnYXV0aG9yaXplJzoge1xuICAgICAgICAgICAgbGV0IHsgY2hhaW4gfSA9IHBhcmFtcztcbiAgICAgICAgICAgIGlmIChwcm90b2NvbFZlcnNpb24gPT09ICdsZWdhY3knKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaGFpbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzb2xhbmE6dGVzdG5ldCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluID0gJ3Rlc3RuZXQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc29sYW5hOmRldm5ldCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluID0gJ2Rldm5ldCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzb2xhbmE6bWFpbm5ldCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluID0gJ21haW5uZXQtYmV0YSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbiA9IHBhcmFtcy5jbHVzdGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtcy5jbHVzdGVyID0gY2hhaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Rlc3RuZXQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkZXZuZXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbiA9IGBzb2xhbmE6JHtjaGFpbn1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWFpbm5ldC1iZXRhJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4gPSAnc29sYW5hOm1haW5uZXQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNoYWluID0gY2hhaW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncmVhdXRob3JpemUnOiB7XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhfdG9rZW4sIGlkZW50aXR5IH0gPSBwYXJhbXM7XG4gICAgICAgICAgICBpZiAoYXV0aF90b2tlbikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvdG9jb2xWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xlZ2FjeSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9ICdyZWF1dGhvcml6ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB7IGF1dGhfdG9rZW46IGF1dGhfdG9rZW4sIGlkZW50aXR5OiBpZGVudGl0eSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gJ2F1dGhvcml6ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1ldGhvZCwgcGFyYW1zIH07XG59XG4vKipcbiAqIEhhbmRsZXMgYWxsIHtAbGluayBNb2JpbGVXYWxsZXR9IEFQSSByZXNwb25zZXMgYW5kIG1vZGlmaWVzIHRoZSByZXNwb25zZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGlmIG5lZWRlZFxuICpcbiAqIEBwYXJhbSBtZXRob2QgdGhlIHtAbGluayBNb2JpbGVXYWxsZXR9IG1ldGhvZCB0aGF0IHdhcyBjYWxsZWRcbiAqIEBwYXJhbSByZXNwb25zZSB0aGUgb3JpZ2luYWwgcmVzcG9uc2UgdGhhdCB3YXMgcmV0dXJuZWQgYnkgdGhlIG1ldGhvZCBjYWxsXG4gKiBAcGFyYW0gcHJvdG9jb2xWZXJzaW9uIHRoZSBwcm90b2NvbCB2ZXJzaW9uIGluIHVzZSBmb3IgdGhpcyBzZXNzaW9uL3JlcXVlc3RcbiAqIEByZXR1cm5zIHRoZSBwb3NzaWJseSBtb2RpZmllZCByZXNwb25zZVxuICovXG5mdW5jdGlvbiBoYW5kbGVNb2JpbGVXYWxsZXRSZXNwb25zZShtZXRob2QsIHJlc3BvbnNlLCBwcm90b2NvbFZlcnNpb24pIHtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICBjYXNlICdnZXRDYXBhYmlsaXRpZXMnOiB7XG4gICAgICAgICAgICBjb25zdCBjYXBhYmlsaXRpZXMgPSByZXNwb25zZTtcbiAgICAgICAgICAgIHN3aXRjaCAocHJvdG9jb2xWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGVnYWN5Jzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZWF0dXJlcyA9IFtTb2xhbmFTaWduVHJhbnNhY3Rpb25zXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcGFiaWxpdGllcy5zdXBwb3J0c19jbG9uZV9hdXRob3JpemF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKFNvbGFuYUNsb25lQXV0aG9yaXphdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2FwYWJpbGl0aWVzKSwgeyBmZWF0dXJlczogZmVhdHVyZXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3YxJzoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjYXBhYmlsaXRpZXMpLCB7IHN1cHBvcnRzX3NpZ25fYW5kX3NlbmRfdHJhbnNhY3Rpb25zOiB0cnVlLCBzdXBwb3J0c19jbG9uZV9hdXRob3JpemF0aW9uOiBjYXBhYmlsaXRpZXMuZmVhdHVyZXMuaW5jbHVkZXMoU29sYW5hQ2xvbmVBdXRob3JpemF0aW9uKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZnVuY3Rpb24gc2lnbkluRmFsbGJhY2soc2lnbkluUGF5bG9hZCwgYXV0aG9yaXphdGlvblJlc3VsdCwgcHJvdG9jb2xSZXF1ZXN0SGFuZGxlcikge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBkb21haW4gPSAoX2EgPSBzaWduSW5QYXlsb2FkLmRvbWFpbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogd2luZG93LmxvY2F0aW9uLmhvc3Q7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhdXRob3JpemF0aW9uUmVzdWx0LmFjY291bnRzWzBdLmFkZHJlc3M7XG4gICAgICAgIGNvbnN0IHNpd3NNZXNzYWdlID0gY3JlYXRlU0lXU01lc3NhZ2VCYXNlNjQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzaWduSW5QYXlsb2FkKSwgeyBkb21haW4sIGFkZHJlc3MgfSkpO1xuICAgICAgICBjb25zdCBzaWduTWVzc2FnZVJlc3VsdCA9IHlpZWxkIHByb3RvY29sUmVxdWVzdEhhbmRsZXIoJ3NpZ25fbWVzc2FnZXMnLCB7XG4gICAgICAgICAgICBhZGRyZXNzZXM6IFthZGRyZXNzXSxcbiAgICAgICAgICAgIHBheWxvYWRzOiBbc2l3c01lc3NhZ2VdXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaWduSW5SZXN1bHQgPSB7XG4gICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgc2lnbmVkX21lc3NhZ2U6IHNpd3NNZXNzYWdlLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBzaWduTWVzc2FnZVJlc3VsdC5zaWduZWRfcGF5bG9hZHNbMF0uc2xpY2Uoc2l3c01lc3NhZ2UubGVuZ3RoKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc2lnbkluUmVzdWx0O1xuICAgIH0pO1xufVxuXG5jb25zdCBTRVFVRU5DRV9OVU1CRVJfQllURVMgPSA0O1xuZnVuY3Rpb24gY3JlYXRlU2VxdWVuY2VOdW1iZXJWZWN0b3Ioc2VxdWVuY2VOdW1iZXIpIHtcbiAgICBpZiAoc2VxdWVuY2VOdW1iZXIgPj0gNDI5NDk2NzI5Nikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dGJvdW5kIHNlcXVlbmNlIG51bWJlciBvdmVyZmxvdy4gVGhlIG1heGltdW0gc2VxdWVuY2UgbnVtYmVyIGlzIDMyLWJ5dGVzLicpO1xuICAgIH1cbiAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgQXJyYXlCdWZmZXIoU0VRVUVOQ0VfTlVNQkVSX0JZVEVTKTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVBcnJheSk7XG4gICAgdmlldy5zZXRVaW50MzIoMCwgc2VxdWVuY2VOdW1iZXIsIC8qIGxpdHRsZUVuZGlhbiAqLyBmYWxzZSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVBcnJheSk7XG59XG5cbmNvbnN0IElOSVRJQUxJWkFUSU9OX1ZFQ1RPUl9CWVRFUyA9IDEyO1xuY29uc3QgRU5DT0RFRF9QVUJMSUNfS0VZX0xFTkdUSF9CWVRFUyA9IDY1O1xuZnVuY3Rpb24gZW5jcnlwdE1lc3NhZ2UocGxhaW50ZXh0LCBzZXF1ZW5jZU51bWJlciwgc2hhcmVkU2VjcmV0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXJWZWN0b3IgPSBjcmVhdGVTZXF1ZW5jZU51bWJlclZlY3RvcihzZXF1ZW5jZU51bWJlcik7XG4gICAgICAgIGNvbnN0IGluaXRpYWxpemF0aW9uVmVjdG9yID0gbmV3IFVpbnQ4QXJyYXkoSU5JVElBTElaQVRJT05fVkVDVE9SX0JZVEVTKTtcbiAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhpbml0aWFsaXphdGlvblZlY3Rvcik7XG4gICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmVuY3J5cHQoZ2V0QWxnb3JpdGhtUGFyYW1zKHNlcXVlbmNlTnVtYmVyVmVjdG9yLCBpbml0aWFsaXphdGlvblZlY3RvciksIHNoYXJlZFNlY3JldCwgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHBsYWludGV4dCkpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBVaW50OEFycmF5KHNlcXVlbmNlTnVtYmVyVmVjdG9yLmJ5dGVMZW5ndGggKyBpbml0aWFsaXphdGlvblZlY3Rvci5ieXRlTGVuZ3RoICsgY2lwaGVydGV4dC5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmVzcG9uc2Uuc2V0KG5ldyBVaW50OEFycmF5KHNlcXVlbmNlTnVtYmVyVmVjdG9yKSwgMCk7XG4gICAgICAgIHJlc3BvbnNlLnNldChuZXcgVWludDhBcnJheShpbml0aWFsaXphdGlvblZlY3RvciksIHNlcXVlbmNlTnVtYmVyVmVjdG9yLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXNwb25zZS5zZXQobmV3IFVpbnQ4QXJyYXkoY2lwaGVydGV4dCksIHNlcXVlbmNlTnVtYmVyVmVjdG9yLmJ5dGVMZW5ndGggKyBpbml0aWFsaXphdGlvblZlY3Rvci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZGVjcnlwdE1lc3NhZ2UobWVzc2FnZSwgc2hhcmVkU2VjcmV0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXJWZWN0b3IgPSBtZXNzYWdlLnNsaWNlKDAsIFNFUVVFTkNFX05VTUJFUl9CWVRFUyk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxpemF0aW9uVmVjdG9yID0gbWVzc2FnZS5zbGljZShTRVFVRU5DRV9OVU1CRVJfQllURVMsIFNFUVVFTkNFX05VTUJFUl9CWVRFUyArIElOSVRJQUxJWkFUSU9OX1ZFQ1RPUl9CWVRFUyk7XG4gICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBtZXNzYWdlLnNsaWNlKFNFUVVFTkNFX05VTUJFUl9CWVRFUyArIElOSVRJQUxJWkFUSU9OX1ZFQ1RPUl9CWVRFUyk7XG4gICAgICAgIGNvbnN0IHBsYWludGV4dEJ1ZmZlciA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuZGVjcnlwdChnZXRBbGdvcml0aG1QYXJhbXMoc2VxdWVuY2VOdW1iZXJWZWN0b3IsIGluaXRpYWxpemF0aW9uVmVjdG9yKSwgc2hhcmVkU2VjcmV0LCBjaXBoZXJ0ZXh0KTtcbiAgICAgICAgY29uc3QgcGxhaW50ZXh0ID0gZ2V0VXRmOERlY29kZXIoKS5kZWNvZGUocGxhaW50ZXh0QnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEFsZ29yaXRobVBhcmFtcyhzZXF1ZW5jZU51bWJlciwgaW5pdGlhbGl6YXRpb25WZWN0b3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRpdGlvbmFsRGF0YTogc2VxdWVuY2VOdW1iZXIsXG4gICAgICAgIGl2OiBpbml0aWFsaXphdGlvblZlY3RvcixcbiAgICAgICAgbmFtZTogJ0FFUy1HQ00nLFxuICAgICAgICB0YWdMZW5ndGg6IDEyOCwgLy8gMTYgYnl0ZSB0YWcgPT4gMTI4IGJpdHNcbiAgICB9O1xufVxubGV0IF91dGY4RGVjb2RlcjtcbmZ1bmN0aW9uIGdldFV0ZjhEZWNvZGVyKCkge1xuICAgIGlmIChfdXRmOERlY29kZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBfdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG4gICAgfVxuICAgIHJldHVybiBfdXRmOERlY29kZXI7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQXNzb2NpYXRpb25LZXlwYWlyKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiB5aWVsZCBjcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgICAgIG5hbWU6ICdFQ0RTQScsXG4gICAgICAgICAgICBuYW1lZEN1cnZlOiAnUC0yNTYnLFxuICAgICAgICB9LCBmYWxzZSAvKiBleHRyYWN0YWJsZSAqLywgWydzaWduJ10gLyoga2V5VXNhZ2VzICovKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVFQ0RIS2V5cGFpcigpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4geWllbGQgY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleSh7XG4gICAgICAgICAgICBuYW1lOiAnRUNESCcsXG4gICAgICAgICAgICBuYW1lZEN1cnZlOiAnUC0yNTYnLFxuICAgICAgICB9LCBmYWxzZSAvKiBleHRyYWN0YWJsZSAqLywgWydkZXJpdmVLZXknLCAnZGVyaXZlQml0cyddIC8qIGtleVVzYWdlcyAqLyk7XG4gICAgfSk7XG59XG5cbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85NDU4OTk2LzgwMjA0N1xuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0Jhc2U2NFN0cmluZyhidWZmZXIpIHtcbiAgICBsZXQgYmluYXJ5ID0gJyc7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IGxlbjsgaWkrKykge1xuICAgICAgICBiaW5hcnkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpaV0pO1xuICAgIH1cbiAgICByZXR1cm4gd2luZG93LmJ0b2EoYmluYXJ5KTtcbn1cblxuZnVuY3Rpb24gZ2V0UmFuZG9tQXNzb2NpYXRpb25Qb3J0KCkge1xuICAgIHJldHVybiBhc3NlcnRBc3NvY2lhdGlvblBvcnQoNDkxNTIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoNjU1MzUgLSA0OTE1MiArIDEpKSk7XG59XG5mdW5jdGlvbiBhc3NlcnRBc3NvY2lhdGlvblBvcnQocG9ydCkge1xuICAgIGlmIChwb3J0IDwgNDkxNTIgfHwgcG9ydCA+IDY1NTM1KSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9BU1NPQ0lBVElPTl9QT1JUX09VVF9PRl9SQU5HRSwgYEFzc29jaWF0aW9uIHBvcnQgbnVtYmVyIG11c3QgYmUgYmV0d2VlbiA0OTE1MiBhbmQgNjU1MzUuICR7cG9ydH0gZ2l2ZW4uYCwgeyBwb3J0IH0pO1xuICAgIH1cbiAgICByZXR1cm4gcG9ydDtcbn1cblxuZnVuY3Rpb24gZ2V0U3RyaW5nV2l0aFVSTFVuc2FmZUNoYXJhY3RlcnNSZXBsYWNlZCh1bnNhZmVCYXNlNjRFbmNvZGVkU3RyaW5nKSB7XG4gICAgcmV0dXJuIHVuc2FmZUJhc2U2NEVuY29kZWRTdHJpbmcucmVwbGFjZSgvWy8rPV0vZywgKG0pID0+ICh7XG4gICAgICAgICcvJzogJ18nLFxuICAgICAgICAnKyc6ICctJyxcbiAgICAgICAgJz0nOiAnLicsXG4gICAgfVttXSkpO1xufVxuXG5jb25zdCBJTlRFTlRfTkFNRSA9ICdzb2xhbmEtd2FsbGV0JztcbmZ1bmN0aW9uIGdldFBhdGhQYXJ0cyhwYXRoU3RyaW5nKSB7XG4gICAgcmV0dXJuIChwYXRoU3RyaW5nXG4gICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXNcbiAgICAgICAgLnJlcGxhY2UoLyheXFwvK3xcXC8rJCkvZywgJycpXG4gICAgICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiBkaXJlY3Rvcmllc1xuICAgICAgICAuc3BsaXQoJy8nKSk7XG59XG5mdW5jdGlvbiBnZXRJbnRlbnRVUkwobWV0aG9kUGF0aG5hbWUsIGludGVudFVybEJhc2UpIHtcbiAgICBsZXQgYmFzZVVybCA9IG51bGw7XG4gICAgaWYgKGludGVudFVybEJhc2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJhc2VVcmwgPSBuZXcgVVJMKGludGVudFVybEJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkgeyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgICAgICAgaWYgKChiYXNlVXJsID09PSBudWxsIHx8IGJhc2VVcmwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJhc2VVcmwucHJvdG9jb2wpICE9PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX0ZPUkJJRERFTl9XQUxMRVRfQkFTRV9VUkwsICdCYXNlIFVSTHMgc3VwcGxpZWQgYnkgd2FsbGV0cyBtdXN0IGJlIHZhbGlkIGBodHRwc2AgVVJMcycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJhc2VVcmwgfHwgKGJhc2VVcmwgPSBuZXcgVVJMKGAke0lOVEVOVF9OQU1FfTovYCkpO1xuICAgIGNvbnN0IHBhdGhuYW1lID0gbWV0aG9kUGF0aG5hbWUuc3RhcnRzV2l0aCgnLycpXG4gICAgICAgID8gLy8gTWV0aG9kIGlzIGFuIGFic29sdXRlIHBhdGguIFJlcGxhY2UgaXQgd2hvbGVzYWxlLlxuICAgICAgICAgICAgbWV0aG9kUGF0aG5hbWVcbiAgICAgICAgOiAvLyBNZXRob2QgaXMgYSByZWxhdGl2ZSBwYXRoLiBNZXJnZSBpdCB3aXRoIHRoZSBleGlzdGluZyBvbmUuXG4gICAgICAgICAgICBbLi4uZ2V0UGF0aFBhcnRzKGJhc2VVcmwucGF0aG5hbWUpLCAuLi5nZXRQYXRoUGFydHMobWV0aG9kUGF0aG5hbWUpXS5qb2luKCcvJyk7XG4gICAgcmV0dXJuIG5ldyBVUkwocGF0aG5hbWUsIGJhc2VVcmwpO1xufVxuZnVuY3Rpb24gZ2V0QXNzb2NpYXRlQW5kcm9pZEludGVudFVSTChhc3NvY2lhdGlvblB1YmxpY0tleSwgcHV0YXRpdmVQb3J0LCBhc3NvY2lhdGlvblVSTEJhc2UsIHByb3RvY29sVmVyc2lvbnMgPSBbJ3YxJ10pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBhc3NvY2lhdGlvblBvcnQgPSBhc3NlcnRBc3NvY2lhdGlvblBvcnQocHV0YXRpdmVQb3J0KTtcbiAgICAgICAgY29uc3QgZXhwb3J0ZWRLZXkgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmV4cG9ydEtleSgncmF3JywgYXNzb2NpYXRpb25QdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCBlbmNvZGVkS2V5ID0gYXJyYXlCdWZmZXJUb0Jhc2U2NFN0cmluZyhleHBvcnRlZEtleSk7XG4gICAgICAgIGNvbnN0IHVybCA9IGdldEludGVudFVSTCgndjEvYXNzb2NpYXRlL2xvY2FsJywgYXNzb2NpYXRpb25VUkxCYXNlKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2Fzc29jaWF0aW9uJywgZ2V0U3RyaW5nV2l0aFVSTFVuc2FmZUNoYXJhY3RlcnNSZXBsYWNlZChlbmNvZGVkS2V5KSk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdwb3J0JywgYCR7YXNzb2NpYXRpb25Qb3J0fWApO1xuICAgICAgICBwcm90b2NvbFZlcnNpb25zLmZvckVhY2goKHZlcnNpb24pID0+IHtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCd2JywgdmVyc2lvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0UmVtb3RlQXNzb2NpYXRlQW5kcm9pZEludGVudFVSTChhc3NvY2lhdGlvblB1YmxpY0tleSwgaG9zdEF1dGhvcml0eSwgcmVmbGVjdG9ySWQsIGFzc29jaWF0aW9uVVJMQmFzZSwgcHJvdG9jb2xWZXJzaW9ucyA9IFsndjEnXSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGV4cG9ydGVkS2V5ID0geWllbGQgY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoJ3JhdycsIGFzc29jaWF0aW9uUHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgZW5jb2RlZEtleSA9IGFycmF5QnVmZmVyVG9CYXNlNjRTdHJpbmcoZXhwb3J0ZWRLZXkpO1xuICAgICAgICBjb25zdCB1cmwgPSBnZXRJbnRlbnRVUkwoJ3YxL2Fzc29jaWF0ZS9yZW1vdGUnLCBhc3NvY2lhdGlvblVSTEJhc2UpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnYXNzb2NpYXRpb24nLCBnZXRTdHJpbmdXaXRoVVJMVW5zYWZlQ2hhcmFjdGVyc1JlcGxhY2VkKGVuY29kZWRLZXkpKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3JlZmxlY3RvcicsIGAke2hvc3RBdXRob3JpdHl9YCk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdpZCcsIGAke2Zyb21VaW50OEFycmF5KHJlZmxlY3RvcklkLCB0cnVlKX1gKTtcbiAgICAgICAgcHJvdG9jb2xWZXJzaW9ucy5mb3JFYWNoKCh2ZXJzaW9uKSA9PiB7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgndicsIHZlcnNpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZW5jcnlwdEpzb25ScGNNZXNzYWdlKGpzb25ScGNNZXNzYWdlLCBzaGFyZWRTZWNyZXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBKU09OLnN0cmluZ2lmeShqc29uUnBjTWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyID0ganNvblJwY01lc3NhZ2UuaWQ7XG4gICAgICAgIHJldHVybiBlbmNyeXB0TWVzc2FnZShwbGFpbnRleHQsIHNlcXVlbmNlTnVtYmVyLCBzaGFyZWRTZWNyZXQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZGVjcnlwdEpzb25ScGNNZXNzYWdlKG1lc3NhZ2UsIHNoYXJlZFNlY3JldCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IHlpZWxkIGRlY3J5cHRNZXNzYWdlKG1lc3NhZ2UsIHNoYXJlZFNlY3JldCk7XG4gICAgICAgIGNvbnN0IGpzb25ScGNNZXNzYWdlID0gSlNPTi5wYXJzZShwbGFpbnRleHQpO1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoanNvblJwY01lc3NhZ2UsICdlcnJvcicpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3IoanNvblJwY01lc3NhZ2UuaWQsIGpzb25ScGNNZXNzYWdlLmVycm9yLmNvZGUsIGpzb25ScGNNZXNzYWdlLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uUnBjTWVzc2FnZTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VIZWxsb1JzcChwYXlsb2FkQnVmZmVyLCAvLyBUaGUgWDkuNjItZW5jb2RlZCB3YWxsZXQgZW5kcG9pbnQgZXBoZW1lcmFsIEVDREggcHVibGljIGtleXBvaW50LlxuYXNzb2NpYXRpb25QdWJsaWNLZXksIGVjZGhQcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgW2Fzc29jaWF0aW9uUHVibGljS2V5QnVmZmVyLCB3YWxsZXRQdWJsaWNLZXldID0geWllbGQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoJ3JhdycsIGFzc29jaWF0aW9uUHVibGljS2V5KSxcbiAgICAgICAgICAgIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBwYXlsb2FkQnVmZmVyLnNsaWNlKDAsIEVOQ09ERURfUFVCTElDX0tFWV9MRU5HVEhfQllURVMpLCB7IG5hbWU6ICdFQ0RIJywgbmFtZWRDdXJ2ZTogJ1AtMjU2JyB9LCBmYWxzZSAvKiBleHRyYWN0YWJsZSAqLywgW10gLyoga2V5VXNhZ2VzICovKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IHNoYXJlZFNlY3JldCA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuZGVyaXZlQml0cyh7IG5hbWU6ICdFQ0RIJywgcHVibGljOiB3YWxsZXRQdWJsaWNLZXkgfSwgZWNkaFByaXZhdGVLZXksIDI1Nik7XG4gICAgICAgIGNvbnN0IGVjZGhTZWNyZXRLZXkgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3Jywgc2hhcmVkU2VjcmV0LCAnSEtERicsIGZhbHNlIC8qIGV4dHJhY3RhYmxlICovLCBbJ2Rlcml2ZUtleSddIC8qIGtleVVzYWdlcyAqLyk7XG4gICAgICAgIGNvbnN0IGFlc0tleU1hdGVyaWFsVmFsID0geWllbGQgY3J5cHRvLnN1YnRsZS5kZXJpdmVLZXkoe1xuICAgICAgICAgICAgbmFtZTogJ0hLREYnLFxuICAgICAgICAgICAgaGFzaDogJ1NIQS0yNTYnLFxuICAgICAgICAgICAgc2FsdDogbmV3IFVpbnQ4QXJyYXkoYXNzb2NpYXRpb25QdWJsaWNLZXlCdWZmZXIpLFxuICAgICAgICAgICAgaW5mbzogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfSwgZWNkaFNlY3JldEtleSwgeyBuYW1lOiAnQUVTLUdDTScsIGxlbmd0aDogMTI4IH0sIGZhbHNlIC8qIGV4dHJhY3RhYmxlICovLCBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcbiAgICAgICAgcmV0dXJuIGFlc0tleU1hdGVyaWFsVmFsO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNlc3Npb25Qcm9wcyhtZXNzYWdlLCBzaGFyZWRTZWNyZXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSB5aWVsZCBkZWNyeXB0TWVzc2FnZShtZXNzYWdlLCBzaGFyZWRTZWNyZXQpO1xuICAgICAgICBjb25zdCBqc29uUHJvcGVydGllcyA9IEpTT04ucGFyc2UocGxhaW50ZXh0KTtcbiAgICAgICAgbGV0IHByb3RvY29sVmVyc2lvbiA9ICdsZWdhY3knO1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoanNvblByb3BlcnRpZXMsICd2JykpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoanNvblByb3BlcnRpZXMudikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjYXNlICcxJzpcbiAgICAgICAgICAgICAgICBjYXNlICd2MSc6XG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sVmVyc2lvbiA9ICd2MSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZ2FjeSc6XG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sVmVyc2lvbiA9ICdsZWdhY3knO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfSU5WQUxJRF9QUk9UT0NPTF9WRVJTSU9OLCBgVW5rbm93bi91bnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uOiAke2pzb25Qcm9wZXJ0aWVzLnZ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICBwcm90b2NvbF92ZXJzaW9uOiBwcm90b2NvbFZlcnNpb25cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8vIFR5cGVzY3JpcHQgYGVudW1zYCB0aHdhcnQgdHJlZS1zaGFraW5nLiBTZWUgaHR0cHM6Ly9iYXJnc3Rlbi5vcmcvanN0cy9lbnVtcy9cbmNvbnN0IEJyb3dzZXIgPSB7XG4gICAgRmlyZWZveDogMCxcbiAgICBPdGhlcjogMSxcbn07XG5mdW5jdGlvbiBhc3NlcnRVbnJlYWNoYWJsZSh4KSB7XG4gICAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBnZXRCcm93c2VyKCkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gvJykgIT09IC0xID8gQnJvd3Nlci5GaXJlZm94IDogQnJvd3Nlci5PdGhlcjtcbn1cbmZ1bmN0aW9uIGdldERldGVjdGlvblByb21pc2UoKSB7XG4gICAgLy8gQ2hyb21lIGFuZCBvdGhlcnMgc2lsZW50bHkgZmFpbCBpZiBhIGN1c3RvbSBwcm90b2NvbCBpcyBub3Qgc3VwcG9ydGVkLlxuICAgIC8vIEZvciB0aGVzZSwgd2Ugd2FpdCB0byBzZWUgaWYgdGhlIGJyb3dzZXIgaXMgbmF2aWdhdGVkIGF3YXkgZnJvbSBpblxuICAgIC8vIGEgcmVhc29uYWJsZSBhbW91bnQgb2YgdGltZSAoaWUuIHRoZSBuYXRpdmUgd2FsbGV0IG9wZW5lZCkuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVCbHVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVCbHVyKCkge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgaGFuZGxlQmx1cik7XG4gICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH0sIDMwMDApO1xuICAgIH0pO1xufVxubGV0IF9mcmFtZSA9IG51bGw7XG5mdW5jdGlvbiBsYXVuY2hVcmxUaHJvdWdoSGlkZGVuRnJhbWUodXJsKSB7XG4gICAgaWYgKF9mcmFtZSA9PSBudWxsKSB7XG4gICAgICAgIF9mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICBfZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChfZnJhbWUpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIF9mcmFtZS5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGxhdW5jaEFzc29jaWF0aW9uKGFzc29jaWF0aW9uVXJsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKGFzc29jaWF0aW9uVXJsLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgLy8gVGhlIGFzc29jaWF0aW9uIFVSTCBpcyBhbiBBbmRyb2lkICdBcHAgTGluaycgb3IgaU9TICdVbml2ZXJzYWwgTGluaycuXG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgcmVndWxhciB3ZWIgVVJMcyB0aGF0IGFyZSBkZXNpZ25lZCB0byBsYXVuY2ggYW4gYXBwIGlmIGl0XG4gICAgICAgICAgICAvLyBpcyBpbnN0YWxsZWQgb3IgbG9hZCB0aGUgYWN0dWFsIHRhcmdldCB3ZWJwYWdlIGlmIG5vdC5cbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24oYXNzb2NpYXRpb25VcmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlIGFzc29jaWF0aW9uIFVSTCBoYXMgYSBjdXN0b20gcHJvdG9jb2wgKGVnLiBgc29sYW5hLXdhbGxldDpgKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYnJvd3Nlcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEJyb3dzZXIuRmlyZWZveDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGEgY3VzdG9tIHByb3RvY29sIGlzIG5vdCBzdXBwb3J0ZWQgaW4gRmlyZWZveCwgaXQgdGhyb3dzLlxuICAgICAgICAgICAgICAgICAgICAgICAgbGF1bmNoVXJsVGhyb3VnaEhpZGRlbkZyYW1lKGFzc29jaWF0aW9uVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgdGhpcyBsaW5lLCBpdCdzIHN1cHBvcnRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEJyb3dzZXIuT3RoZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRldGVjdGlvblByb21pc2UgPSBnZXREZXRlY3Rpb25Qcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKGFzc29jaWF0aW9uVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIGRldGVjdGlvblByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0VW5yZWFjaGFibGUoYnJvd3Nlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfV0FMTEVUX05PVF9GT1VORCwgJ0ZvdW5kIG5vIGluc3RhbGxlZCB3YWxsZXQgdGhhdCBzdXBwb3J0cyB0aGUgbW9iaWxlIHdhbGxldCBwcm90b2NvbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc3RhcnRTZXNzaW9uKGFzc29jaWF0aW9uUHVibGljS2V5LCBhc3NvY2lhdGlvblVSTEJhc2UpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCByYW5kb21Bc3NvY2lhdGlvblBvcnQgPSBnZXRSYW5kb21Bc3NvY2lhdGlvblBvcnQoKTtcbiAgICAgICAgY29uc3QgYXNzb2NpYXRpb25VcmwgPSB5aWVsZCBnZXRBc3NvY2lhdGVBbmRyb2lkSW50ZW50VVJMKGFzc29jaWF0aW9uUHVibGljS2V5LCByYW5kb21Bc3NvY2lhdGlvblBvcnQsIGFzc29jaWF0aW9uVVJMQmFzZSk7XG4gICAgICAgIHlpZWxkIGxhdW5jaEFzc29jaWF0aW9uKGFzc29jaWF0aW9uVXJsKTtcbiAgICAgICAgcmV0dXJuIHJhbmRvbUFzc29jaWF0aW9uUG9ydDtcbiAgICB9KTtcbn1cblxuY29uc3QgV0VCU09DS0VUX0NPTk5FQ1RJT05fQ09ORklHID0ge1xuICAgIC8qKlxuICAgICAqIDMwMCBtaWxsaXNlY29uZHMgaXMgYSBnZW5lcmFsbHkgYWNjZXB0ZWQgdGhyZXNob2xkIGZvciB3aGF0IHNvbWVvbmVcbiAgICAgKiB3b3VsZCBjb25zaWRlciBhbiBhY2NlcHRhYmxlIHJlc3BvbnNlIHRpbWUgZm9yIGEgdXNlciBpbnRlcmZhY2VcbiAgICAgKiBhZnRlciBoYXZpbmcgcGVyZm9ybWVkIGEgbG93LWF0dGVudGlvbiB0YXBwaW5nIHRhc2suIFdlIHNldCB0aGUgaW5pdGlhbFxuICAgICAqIGludGVydmFsIGF0IHdoaWNoIHdlIHdhaXQgZm9yIHRoZSB3YWxsZXQgdG8gc2V0IHVwIHRoZSB3ZWJzb2NrZXQgYXRcbiAgICAgKiBoYWxmIHRoaXMsIGFzIHBlciB0aGUgTnlxdWlzdCBmcmVxdWVuY3ksIHdpdGggYSBwcm9ncmVzc2l2ZSBiYWNrb2ZmXG4gICAgICogc2VxdWVuY2UgZnJvbSB0aGVyZS4gVGhlIHRvdGFsIHdhaXQgdGltZSBpcyAzMHMsIHdoaWNoIGFsbG93cyBmb3IgdGhlXG4gICAgICogdXNlciB0byBiZSBwcmVzZW50ZWQgd2l0aCBhIGRpc2FtYmlndWF0aW9uIGRpYWxvZywgc2VsZWN0IGEgd2FsbGV0LCBhbmRcbiAgICAgKiBmb3IgdGhlIHdhbGxldCBhcHAgdG8gc3Vic2VxdWVudGx5IHN0YXJ0LlxuICAgICAqL1xuICAgIHJldHJ5RGVsYXlTY2hlZHVsZU1zOiBbMTUwLCAxNTAsIDIwMCwgNTAwLCA1MDAsIDc1MCwgNzUwLCAxMDAwXSxcbiAgICB0aW1lb3V0TXM6IDMwMDAwLFxufTtcbmNvbnN0IFdFQlNPQ0tFVF9QUk9UT0NPTF9CSU5BUlkgPSAnY29tLnNvbGFuYS5tb2JpbGV3YWxsZXRhZGFwdGVyLnYxJztcbmNvbnN0IFdFQlNPQ0tFVF9QUk9UT0NPTF9CQVNFNjQgPSAnY29tLnNvbGFuYS5tb2JpbGV3YWxsZXRhZGFwdGVyLnYxLmJhc2U2NCc7XG5mdW5jdGlvbiBhc3NlcnRTZWN1cmVDb250ZXh0KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB3aW5kb3cuaXNTZWN1cmVDb250ZXh0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9TRUNVUkVfQ09OVEVYVF9SRVFVSVJFRCwgJ1RoZSBtb2JpbGUgd2FsbGV0IGFkYXB0ZXIgcHJvdG9jb2wgbXVzdCBiZSB1c2VkIGluIGEgc2VjdXJlIGNvbnRleHQgKGBodHRwc2ApLicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydFNlY3VyZUVuZHBvaW50U3BlY2lmaWNVUkkod2FsbGV0VXJpQmFzZSkge1xuICAgIGxldCB1cmw7XG4gICAgdHJ5IHtcbiAgICAgICAgdXJsID0gbmV3IFVSTCh3YWxsZXRVcmlCYXNlKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9GT1JCSURERU5fV0FMTEVUX0JBU0VfVVJMLCAnSW52YWxpZCBiYXNlIFVSTCBzdXBwbGllZCBieSB3YWxsZXQnKTtcbiAgICB9XG4gICAgaWYgKHVybC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX0ZPUkJJRERFTl9XQUxMRVRfQkFTRV9VUkwsICdCYXNlIFVSTHMgc3VwcGxpZWQgYnkgd2FsbGV0cyBtdXN0IGJlIHZhbGlkIGBodHRwc2AgVVJMcycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNlcXVlbmNlTnVtYmVyRnJvbUJ5dGVBcnJheShieXRlQXJyYXkpIHtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVBcnJheSk7XG4gICAgcmV0dXJuIHZpZXcuZ2V0VWludDMyKDAsIC8qIGxpdHRsZUVuZGlhbiAqLyBmYWxzZSk7XG59XG5mdW5jdGlvbiBkZWNvZGVWYXJMb25nKGJ5dGVBcnJheSkge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVBcnJheSksIGwgPSBieXRlQXJyYXkuYnl0ZUxlbmd0aCwgbGltaXQgPSAxMCwgdmFsdWUgPSAwLCBvZmZzZXQgPSAwLCBiO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKG9mZnNldCA+PSBsIHx8IG9mZnNldCA+IGxpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ZhaWxlZCB0byBkZWNvZGUgdmFyaW50Jyk7XG4gICAgICAgIGIgPSBieXRlc1tvZmZzZXQrK107XG4gICAgICAgIHZhbHVlIHw9IChiICYgMHg3RikgPDwgKDcgKiBvZmZzZXQpO1xuICAgIH0gd2hpbGUgKGIgPj0gMHg4MCk7XG4gICAgcmV0dXJuIHsgdmFsdWUsIG9mZnNldCB9O1xufVxuZnVuY3Rpb24gZ2V0UmVmbGVjdG9ySWRGcm9tQnl0ZUFycmF5KGJ5dGVBcnJheSkge1xuICAgIGxldCB7IHZhbHVlOiBsZW5ndGgsIG9mZnNldCB9ID0gZGVjb2RlVmFyTG9uZyhieXRlQXJyYXkpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlQXJyYXkuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpKTtcbn1cbmZ1bmN0aW9uIHRyYW5zYWN0KGNhbGxiYWNrLCBjb25maWcpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBhc3NlcnRTZWN1cmVDb250ZXh0KCk7XG4gICAgICAgIGNvbnN0IGFzc29jaWF0aW9uS2V5cGFpciA9IHlpZWxkIGdlbmVyYXRlQXNzb2NpYXRpb25LZXlwYWlyKCk7XG4gICAgICAgIGNvbnN0IHNlc3Npb25Qb3J0ID0geWllbGQgc3RhcnRTZXNzaW9uKGFzc29jaWF0aW9uS2V5cGFpci5wdWJsaWNLZXksIGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5iYXNlVXJpKTtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0VVJMID0gYHdzOi8vbG9jYWxob3N0OiR7c2Vzc2lvblBvcnR9L3NvbGFuYS13YWxsZXRgO1xuICAgICAgICBsZXQgY29ubmVjdGlvblN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgZ2V0TmV4dFJldHJ5RGVsYXlNcyA9ICgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hlZHVsZSA9IFsuLi5XRUJTT0NLRVRfQ09OTkVDVElPTl9DT05GSUcucmV0cnlEZWxheVNjaGVkdWxlTXNdO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IChzY2hlZHVsZS5sZW5ndGggPiAxID8gc2NoZWR1bGUuc2hpZnQoKSA6IHNjaGVkdWxlWzBdKTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgbGV0IG5leHRKc29uUnBjTWVzc2FnZUlkID0gMTtcbiAgICAgICAgbGV0IGxhc3RLbm93bkluYm91bmRTZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgICAgIGxldCBzdGF0ZSA9IHsgX190eXBlOiAnZGlzY29ubmVjdGVkJyB9O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IHNvY2tldDtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBjb25zdCBqc29uUnBjUmVzcG9uc2VQcm9taXNlcyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlT3BlbiA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuX190eXBlICE9PSAnY29ubmVjdGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdFeHBlY3RlZCBhZGFwdGVyIHN0YXRlIHRvIGJlIGBjb25uZWN0aW5nYCBhdCB0aGUgbW9tZW50IHRoZSB3ZWJzb2NrZXQgb3BlbnMuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYEdvdCBcXGAke3N0YXRlLl9fdHlwZX1cXGAuYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wZW4nLCBoYW5kbGVPcGVuKTtcbiAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyB2ZXJzaW9ucyBvZiB0aGlzIGxpYnJhcnkgYW5kIHdhbGxldGxpYiBpbmNvcnJlY3RseSBpbXBsZW1lbnRlZCB0aGUgTVdBIHNlc3Npb24gXG4gICAgICAgICAgICAgICAgLy8gZXN0YWJsaXNobWVudCBwcm90b2NvbCBmb3IgbG9jYWwgY29ubmVjdGlvbnMuIFRoZSBkYXBwIGlzIHN1cHBvc2VkIHRvIHdhaXQgZm9yIHRoZSBcbiAgICAgICAgICAgICAgICAvLyBBUFBfUElORyBtZXNzYWdlIGJlZm9yZSBzZW5kaW5nIHRoZSBIRUxMT19SRVEuIEluc3RlYWQsIHRoZSBkYXBwIHdhcyBzZW5kaW5nIHRoZSBIRUxMT19SRVEgXG4gICAgICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHkgdXBvbiBjb25uZWN0aW9uIHRvIHRoZSB3ZWJzb2NrZXQgc2VydmVyIHJlZ2FyZGxlc3Mgb2Ygd2V0aGVyIG9yIG5vdCBhbiBcbiAgICAgICAgICAgICAgICAvLyBBUFBfUElORyB3YXMgc2VudCBieSB0aGUgd2FsbGV0L3dlYnNvY2tldCBzZXJ2ZXIuIFdlIG11c3QgY29udGludWUgdG8gc3VwcG9ydCB0aGlzIGJlaGF2aW9yIFxuICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIHVzZXIgaXMgdXNpbmcgYSB3YWxsZXQgdGhhdCBoYXMgbm90IHVwZGF0ZWQgdGhlaXIgd2FsbGV0bGliIGltcGxlbWVudGF0aW9uLiBcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFzc29jaWF0aW9uS2V5cGFpciB9ID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgZWNkaEtleXBhaXIgPSB5aWVsZCBnZW5lcmF0ZUVDREhLZXlwYWlyKCk7XG4gICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoeWllbGQgY3JlYXRlSGVsbG9SZXEoZWNkaEtleXBhaXIucHVibGljS2V5LCBhc3NvY2lhdGlvbktleXBhaXIucHJpdmF0ZUtleSkpO1xuICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICBfX3R5cGU6ICdoZWxsb19yZXFfc2VudCcsXG4gICAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uUHVibGljS2V5OiBhc3NvY2lhdGlvbktleXBhaXIucHVibGljS2V5LFxuICAgICAgICAgICAgICAgICAgICBlY2RoUHJpdmF0ZUtleTogZWNkaEtleXBhaXIucHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVDbG9zZSA9IChldnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZ0Lndhc0NsZWFuKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyBfX3R5cGU6ICdkaXNjb25uZWN0ZWQnIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1NFU1NJT05fQ0xPU0VELCBgVGhlIHdhbGxldCBzZXNzaW9uIGRyb3BwZWQgdW5leHBlY3RlZGx5ICgke2V2dC5jb2RlfTogJHtldnQucmVhc29ufSkuYCwgeyBjbG9zZUV2ZW50OiBldnQgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwb3NlU29ja2V0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoX2V2dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIGNvbm5lY3Rpb25TdGFydFRpbWUgPj0gV0VCU09DS0VUX0NPTk5FQ1RJT05fQ09ORklHLnRpbWVvdXRNcykge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1NFU1NJT05fVElNRU9VVCwgYEZhaWxlZCB0byBjb25uZWN0IHRvIHRoZSB3YWxsZXQgd2Vic29ja2V0IGF0ICR7d2Vic29ja2V0VVJMfS5gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0cnlEZWxheU1zID0gZ2V0TmV4dFJldHJ5RGVsYXlNcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlXYWl0VGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheU1zKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRTb2NrZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVNZXNzYWdlID0gKGV2dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQnVmZmVyID0geWllbGQgZXZ0LmRhdGEuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlLl9fdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0aW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUJ1ZmZlci5ieXRlTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvdW50ZXJlZCB1bmV4cGVjdGVkIG1lc3NhZ2Ugd2hpbGUgY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNkaEtleXBhaXIgPSB5aWVsZCBnZW5lcmF0ZUVDREhLZXlwYWlyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZCh5aWVsZCBjcmVhdGVIZWxsb1JlcShlY2RoS2V5cGFpci5wdWJsaWNLZXksIGFzc29jaWF0aW9uS2V5cGFpci5wcml2YXRlS2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3R5cGU6ICdoZWxsb19yZXFfc2VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb25QdWJsaWNLZXk6IGFzc29jaWF0aW9uS2V5cGFpci5wdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWNkaFByaXZhdGVLZXk6IGVjZGhLZXlwYWlyLnByaXZhdGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyVmVjdG9yID0gcmVzcG9uc2VCdWZmZXIuc2xpY2UoMCwgU0VRVUVOQ0VfTlVNQkVSX0JZVEVTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlciA9IGdldFNlcXVlbmNlTnVtYmVyRnJvbUJ5dGVBcnJheShzZXF1ZW5jZU51bWJlclZlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVyICE9PSAobGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0ZWQgbWVzc2FnZSBoYXMgaW52YWxpZCBzZXF1ZW5jZSBudW1iZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QganNvblJwY01lc3NhZ2UgPSB5aWVsZCBkZWNyeXB0SnNvblJwY01lc3NhZ2UocmVzcG9uc2VCdWZmZXIsIHN0YXRlLnNoYXJlZFNlY3JldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0ganNvblJwY1Jlc3BvbnNlUHJvbWlzZXNbanNvblJwY01lc3NhZ2UuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tqc29uUnBjTWVzc2FnZS5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlc29sdmUoanNvblJwY01lc3NhZ2UucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tlLmpzb25ScGNNZXNzYWdlSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUganNvblJwY1Jlc3BvbnNlUHJvbWlzZXNbZS5qc29uUnBjTWVzc2FnZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hlbGxvX3JlcV9zZW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgcmVjZWl2ZSBhbiBBUFBfUElORyBtZXNzYWdlIChlbXB0eSBtZXNzYWdlKSwgcmVzZW5kIHRoZSBIRUxMT19SRVEgKHNlZSBhYm92ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWNkaEtleXBhaXIgPSB5aWVsZCBnZW5lcmF0ZUVDREhLZXlwYWlyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoeWllbGQgY3JlYXRlSGVsbG9SZXEoZWNkaEtleXBhaXIucHVibGljS2V5LCBhc3NvY2lhdGlvbktleXBhaXIucHJpdmF0ZUtleSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3R5cGU6ICdoZWxsb19yZXFfc2VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uUHVibGljS2V5OiBhc3NvY2lhdGlvbktleXBhaXIucHVibGljS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlY2RoUHJpdmF0ZUtleTogZWNkaEtleXBhaXIucHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hhcmVkU2VjcmV0ID0geWllbGQgcGFyc2VIZWxsb1JzcChyZXNwb25zZUJ1ZmZlciwgc3RhdGUuYXNzb2NpYXRpb25QdWJsaWNLZXksIHN0YXRlLmVjZGhQcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyID0gcmVzcG9uc2VCdWZmZXIuc2xpY2UoRU5DT0RFRF9QVUJMSUNfS0VZX0xFTkdUSF9CWVRFUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uUHJvcGVydGllcyA9IHNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyLmJ5dGVMZW5ndGggIT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHlpZWxkICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyVmVjdG9yID0gc2Vzc2lvblByb3BlcnRpZXNCdWZmZXIuc2xpY2UoMCwgU0VRVUVOQ0VfTlVNQkVSX0JZVEVTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXIgPSBnZXRTZXF1ZW5jZU51bWJlckZyb21CeXRlQXJyYXkoc2VxdWVuY2VOdW1iZXJWZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2VOdW1iZXIgIT09IChsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0ZWQgbWVzc2FnZSBoYXMgaW52YWxpZCBzZXF1ZW5jZSBudW1iZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlU2Vzc2lvblByb3BzKHNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyLCBzaGFyZWRTZWNyZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSgpIDogeyBwcm90b2NvbF92ZXJzaW9uOiAnbGVnYWN5JyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IF9fdHlwZTogJ2Nvbm5lY3RlZCcsIHNoYXJlZFNlY3JldCwgc2Vzc2lvblByb3BlcnRpZXMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhbGxldCA9IGNyZWF0ZU1vYmlsZVdhbGxldFByb3h5KHNlc3Npb25Qcm9wZXJ0aWVzLnByb3RvY29sX3ZlcnNpb24sIChtZXRob2QsIHBhcmFtcykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gbmV4dEpzb25ScGNNZXNzYWdlSWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZCh5aWVsZCBlbmNyeXB0SnNvblJwY01lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBzaGFyZWRTZWNyZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F1dGhvcml6ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlYXV0aG9yaXplJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB3YWxsZXRfdXJpX2Jhc2UgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YWxsZXRfdXJpX2Jhc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydFNlY3VyZUVuZHBvaW50U3BlY2lmaWNVUkkod2FsbGV0X3VyaV9iYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh5aWVsZCBjYWxsYmFjayh3YWxsZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBkaXNwb3NlU29ja2V0O1xuICAgICAgICAgICAgbGV0IHJldHJ5V2FpdFRpbWVvdXRJZDtcbiAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRTb2NrZXRDb25uZWN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkaXNwb3NlU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUgPSB7IF9fdHlwZTogJ2Nvbm5lY3RpbmcnLCBhc3NvY2lhdGlvbktleXBhaXIgfTtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvblN0YXJ0VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25TdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHdlYnNvY2tldFVSTCwgW1dFQlNPQ0tFVF9QUk9UT0NPTF9CSU5BUlldKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGhhbmRsZU9wZW4pO1xuICAgICAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGhhbmRsZUNsb3NlKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBkaXNwb3NlU29ja2V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHJldHJ5V2FpdFRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgaGFuZGxlT3Blbik7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIGhhbmRsZUNsb3NlKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXR0ZW1wdFNvY2tldENvbm5lY3Rpb24oKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzdGFydFJlbW90ZVNjZW5hcmlvKGNvbmZpZykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGFzc2VydFNlY3VyZUNvbnRleHQoKTtcbiAgICAgICAgY29uc3QgYXNzb2NpYXRpb25LZXlwYWlyID0geWllbGQgZ2VuZXJhdGVBc3NvY2lhdGlvbktleXBhaXIoKTtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0VVJMID0gYHdzczovLyR7Y29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLnJlbW90ZUhvc3RBdXRob3JpdHl9L3JlZmxlY3RgO1xuICAgICAgICBsZXQgY29ubmVjdGlvblN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgZ2V0TmV4dFJldHJ5RGVsYXlNcyA9ICgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hlZHVsZSA9IFsuLi5XRUJTT0NLRVRfQ09OTkVDVElPTl9DT05GSUcucmV0cnlEZWxheVNjaGVkdWxlTXNdO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IChzY2hlZHVsZS5sZW5ndGggPiAxID8gc2NoZWR1bGUuc2hpZnQoKSA6IHNjaGVkdWxlWzBdKTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgbGV0IG5leHRKc29uUnBjTWVzc2FnZUlkID0gMTtcbiAgICAgICAgbGV0IGxhc3RLbm93bkluYm91bmRTZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgICAgIGxldCBlbmNvZGluZztcbiAgICAgICAgbGV0IHN0YXRlID0geyBfX3R5cGU6ICdkaXNjb25uZWN0ZWQnIH07XG4gICAgICAgIGxldCBzb2NrZXQ7XG4gICAgICAgIGxldCBkaXNwb3NlU29ja2V0O1xuICAgICAgICBsZXQgZGVjb2RlQnl0ZXMgPSAoZXZ0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT0gJ2Jhc2U2NCcpIHsgLy8gYmFzZTY0IGVuY29kaW5nXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHlpZWxkIGV2dC5kYXRhO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b1VpbnQ4QXJyYXkobWVzc2FnZSkuYnVmZmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGV2dC5kYXRhLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZWZsZWN0b3IgQ29ubmVjdGlvbiBQaGFzZVxuICAgICAgICAvLyBoZXJlIHdlIGNvbm5lY3QgdG8gdGhlIHJlZmxlY3RvciBhbmQgd2FpdCBmb3IgdGhlIFJFRkxFQ1RPUl9JRCBtZXNzYWdlIFxuICAgICAgICAvLyBzbyB3ZSBidWlsZCB0aGUgYXNzb2NpYXRpb24gVVJMIGFuZCByZXR1cm4gdGhhdCBiYWNrIHRvIHRoZSBjYWxsZXJcbiAgICAgICAgY29uc3QgYXNzb2NpYXRpb25VcmwgPSB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVPcGVuID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5fX3R5cGUgIT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIGFkYXB0ZXIgc3RhdGUgdG8gYmUgYGNvbm5lY3RpbmdgIGF0IHRoZSBtb21lbnQgdGhlIHdlYnNvY2tldCBvcGVucy4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBgR290IFxcYCR7c3RhdGUuX190eXBlfVxcYC5gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc29ja2V0LnByb3RvY29sLmluY2x1ZGVzKFdFQlNPQ0tFVF9QUk9UT0NPTF9CQVNFNjQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nID0gJ2Jhc2U2NCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZyA9ICdiaW5hcnknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIGhhbmRsZU9wZW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVDbG9zZSA9IChldnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZ0Lndhc0NsZWFuKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyBfX3R5cGU6ICdkaXNjb25uZWN0ZWQnIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1NFU1NJT05fQ0xPU0VELCBgVGhlIHdhbGxldCBzZXNzaW9uIGRyb3BwZWQgdW5leHBlY3RlZGx5ICgke2V2dC5jb2RlfTogJHtldnQucmVhc29ufSkuYCwgeyBjbG9zZUV2ZW50OiBldnQgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwb3NlU29ja2V0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoX2V2dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIGNvbm5lY3Rpb25TdGFydFRpbWUgPj0gV0VCU09DS0VUX0NPTk5FQ1RJT05fQ09ORklHLnRpbWVvdXRNcykge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX1NFU1NJT05fVElNRU9VVCwgYEZhaWxlZCB0byBjb25uZWN0IHRvIHRoZSB3YWxsZXQgd2Vic29ja2V0IGF0ICR7d2Vic29ja2V0VVJMfS5gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0cnlEZWxheU1zID0gZ2V0TmV4dFJldHJ5RGVsYXlNcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlXYWl0VGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheU1zKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRTb2NrZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVSZWZsZWN0b3JJZE1lc3NhZ2UgPSAoZXZ0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCdWZmZXIgPSB5aWVsZCBkZWNvZGVCeXRlcyhldnQpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5fX3R5cGUgPT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VCdWZmZXIuYnl0ZUxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY291bnRlcmVkIHVuZXhwZWN0ZWQgbWVzc2FnZSB3aGlsZSBjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmbGVjdG9ySWQgPSBnZXRSZWZsZWN0b3JJZEZyb21CeXRlQXJyYXkocmVzcG9uc2VCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fdHlwZTogJ3JlZmxlY3Rvcl9pZF9yZWNlaXZlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZsZWN0b3JJZDogcmVmbGVjdG9ySWRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNzb2NpYXRpb25VcmwgPSB5aWVsZCBnZXRSZW1vdGVBc3NvY2lhdGVBbmRyb2lkSW50ZW50VVJMKGFzc29jaWF0aW9uS2V5cGFpci5wdWJsaWNLZXksIGNvbmZpZy5yZW1vdGVIb3N0QXV0aG9yaXR5LCByZWZsZWN0b3JJZCwgY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmJhc2VVcmkpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZVJlZmxlY3RvcklkTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYXNzb2NpYXRpb25VcmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHJldHJ5V2FpdFRpbWVvdXRJZDtcbiAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRTb2NrZXRDb25uZWN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkaXNwb3NlU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUgPSB7IF9fdHlwZTogJ2Nvbm5lY3RpbmcnLCBhc3NvY2lhdGlvbktleXBhaXIgfTtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvblN0YXJ0VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25TdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHdlYnNvY2tldFVSTCwgW1dFQlNPQ0tFVF9QUk9UT0NPTF9CSU5BUlksIFdFQlNPQ0tFVF9QUk9UT0NPTF9CQVNFNjRdKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGhhbmRsZU9wZW4pO1xuICAgICAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGhhbmRsZUNsb3NlKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVSZWZsZWN0b3JJZE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQocmV0cnlXYWl0VGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wZW4nLCBoYW5kbGVPcGVuKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgaGFuZGxlQ2xvc2UpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlUmVmbGVjdG9ySWRNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF0dGVtcHRTb2NrZXRDb25uZWN0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXYWxsZXQgQ29ubmVjdGlvbiBQaGFzZVxuICAgICAgICAvLyBoZXJlIHdlIHJldHVybiB0aGUgYXNzb2NpYXRpb24gVVJMIChjb250YWluaW5nIHRoZSByZWZsZWN0b3IgSUQpIHRvIHRoZSBjYWxsZXIgKyBcbiAgICAgICAgLy8gYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHRoZSBNb2JpbGVXYWxsZXQgb2JqZWN0IG9uY2UgdGhlIHdhbGxldCBjb25uZWN0cy5cbiAgICAgICAgbGV0IHNlc3Npb25Fc3RhYmxpc2hlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgaGFuZGxlQ2xvc2U7XG4gICAgICAgIHJldHVybiB7IGFzc29jaWF0aW9uVXJsLCBjbG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGhhbmRsZUNsb3NlKCk7XG4gICAgICAgICAgICB9LCB3YWxsZXQ6IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGNvbnN0IGpzb25ScGNSZXNwb25zZVByb21pc2VzID0ge307XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlTWVzc2FnZSA9IChldnQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCdWZmZXIgPSB5aWVsZCBkZWNvZGVCeXRlcyhldnQpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlLl9fdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVmbGVjdG9yX2lkX3JlY2VpdmVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VCdWZmZXIuYnl0ZUxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY291bnRlcmVkIHVuZXhwZWN0ZWQgbWVzc2FnZSB3aGlsZSBhd2FpdGluZyByZWZsZWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVjZGhLZXlwYWlyID0geWllbGQgZ2VuZXJhdGVFQ0RIS2V5cGFpcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpbmFyeU1zZyA9IHlpZWxkIGNyZWF0ZUhlbGxvUmVxKGVjZGhLZXlwYWlyLnB1YmxpY0tleSwgYXNzb2NpYXRpb25LZXlwYWlyLnByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZyA9PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChmcm9tVWludDhBcnJheShiaW5hcnlNc2cpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKGJpbmFyeU1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3R5cGU6ICdoZWxsb19yZXFfc2VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uUHVibGljS2V5OiBhc3NvY2lhdGlvbktleXBhaXIucHVibGljS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlY2RoUHJpdmF0ZUtleTogZWNkaEtleXBhaXIucHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlclZlY3RvciA9IHJlc3BvbnNlQnVmZmVyLnNsaWNlKDAsIFNFUVVFTkNFX05VTUJFUl9CWVRFUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyID0gZ2V0U2VxdWVuY2VOdW1iZXJGcm9tQnl0ZUFycmF5KHNlcXVlbmNlTnVtYmVyVmVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVyICE9PSAobGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGVkIG1lc3NhZ2UgaGFzIGludmFsaWQgc2VxdWVuY2UgbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGpzb25ScGNNZXNzYWdlID0geWllbGQgZGVjcnlwdEpzb25ScGNNZXNzYWdlKHJlc3BvbnNlQnVmZmVyLCBzdGF0ZS5zaGFyZWRTZWNyZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tqc29uUnBjTWVzc2FnZS5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tqc29uUnBjTWVzc2FnZS5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZXNvbHZlKGpzb25ScGNNZXNzYWdlLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IGpzb25ScGNSZXNwb25zZVByb21pc2VzW2UuanNvblJwY01lc3NhZ2VJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUganNvblJwY1Jlc3BvbnNlUHJvbWlzZXNbZS5qc29uUnBjTWVzc2FnZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaGVsbG9fcmVxX3NlbnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hhcmVkU2VjcmV0ID0geWllbGQgcGFyc2VIZWxsb1JzcChyZXNwb25zZUJ1ZmZlciwgc3RhdGUuYXNzb2NpYXRpb25QdWJsaWNLZXksIHN0YXRlLmVjZGhQcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uUHJvcGVydGllc0J1ZmZlciA9IHJlc3BvbnNlQnVmZmVyLnNsaWNlKEVOQ09ERURfUFVCTElDX0tFWV9MRU5HVEhfQllURVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25Qcm9wZXJ0aWVzID0gc2Vzc2lvblByb3BlcnRpZXNCdWZmZXIuYnl0ZUxlbmd0aCAhPT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHlpZWxkICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlclZlY3RvciA9IHNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyLnNsaWNlKDAsIFNFUVVFTkNFX05VTUJFUl9CWVRFUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlciA9IGdldFNlcXVlbmNlTnVtYmVyRnJvbUJ5dGVBcnJheShzZXF1ZW5jZU51bWJlclZlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2VOdW1iZXIgIT09IChsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGVkIG1lc3NhZ2UgaGFzIGludmFsaWQgc2VxdWVuY2UgbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVNlc3Npb25Qcm9wcyhzZXNzaW9uUHJvcGVydGllc0J1ZmZlciwgc2hhcmVkU2VjcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKCkgOiB7IHByb3RvY29sX3ZlcnNpb246ICdsZWdhY3knIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IF9fdHlwZTogJ2Nvbm5lY3RlZCcsIHNoYXJlZFNlY3JldCwgc2Vzc2lvblByb3BlcnRpZXMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3YWxsZXQgPSBjcmVhdGVNb2JpbGVXYWxsZXRQcm94eShzZXNzaW9uUHJvcGVydGllcy5wcm90b2NvbF92ZXJzaW9uLCAobWV0aG9kLCBwYXJhbXMpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaWQgPSBuZXh0SnNvblJwY01lc3NhZ2VJZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiaW5hcnlNc2cgPSB5aWVsZCBlbmNyeXB0SnNvblJwY01lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHNoYXJlZFNlY3JldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZyA9PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoZnJvbVVpbnQ4QXJyYXkoYmluYXJ5TXNnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChiaW5hcnlNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F1dGhvcml6ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyZWF1dGhvcml6ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHdhbGxldF91cmlfYmFzZSB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YWxsZXRfdXJpX2Jhc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0U2VjdXJlRW5kcG9pbnRTcGVjaWZpY1VSSSh3YWxsZXRfdXJpX2Jhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25Fc3RhYmxpc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh3YWxsZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVDbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb25Fc3RhYmxpc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9TRVNTSU9OX0NMT1NFRCwgYFRoZSB3YWxsZXQgc2Vzc2lvbiB3YXMgY2xvc2VkIGJlZm9yZSBjb25uZWN0aW9uLmAsIHsgY2xvc2VFdmVudDogbmV3IENsb3NlRXZlbnQoJ3NvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSBjb25uZWN0aW9uJykgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pIH07XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IFNvbGFuYUNsb25lQXV0aG9yaXphdGlvbiwgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yLCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvciwgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3JDb2RlLCBTb2xhbmFTaWduSW5XaXRoU29sYW5hLCBTb2xhbmFTaWduVHJhbnNhY3Rpb25zLCBzdGFydFJlbW90ZVNjZW5hcmlvLCB0cmFuc2FjdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@solana-mobile+mobile-walle_fa759a545cf2947ec576f93cdfb8b072/node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js\n");

/***/ })

};
;