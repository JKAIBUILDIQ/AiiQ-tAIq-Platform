"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/trading-utils.ts":
/*!******************************!*\
  !*** ./lib/trading-utils.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeEquity: function() { return /* binding */ computeEquity; },\n/* harmony export */   computeStats: function() { return /* binding */ computeStats; },\n/* harmony export */   computeStrategyEquity: function() { return /* binding */ computeStrategyEquity; }\n/* harmony export */ });\n// Very simple equity curve: buy-and-hold on closes (placeholder for presets)\nfunction computeEquity(candles) {\n    if (!candles.length) return [];\n    const first = candles[0].close;\n    let equity = 1;\n    const out = [];\n    for(let i = 0; i < candles.length; i++){\n        const ret = i === 0 ? 0 : (candles[i].close - candles[i - 1].close) / candles[i - 1].close;\n        equity *= 1 + ret;\n        out.push({\n            time: candles[i].time,\n            value: equity\n        });\n    }\n    return out;\n}\nfunction computeStats(candles, equity) {\n    if (!candles.length || !equity.length) return {\n        pnlPct: 0,\n        sharpe: 0,\n        winRate: 0,\n        maxDD: 0\n    };\n    const rets = [];\n    for(let i = 1; i < candles.length; i++){\n        const r = (candles[i].close - candles[i - 1].close) / candles[i - 1].close;\n        rets.push(r);\n    }\n    const mean = rets.reduce((a, b)=>a + b, 0) / rets.length;\n    const std = Math.sqrt(rets.reduce((a, b)=>a + Math.pow(b - mean, 2), 0) / Math.max(1, rets.length - 1));\n    const sharpe = std > 0 ? mean / std * Math.sqrt(252) : 0;\n    const winRate = rets.filter((r)=>r > 0).length / rets.length;\n    const pnlPct = (equity[equity.length - 1].value - 1) * 100;\n    // Max drawdown\n    let peak = equity[0].value;\n    let maxDD = 0;\n    for (const p of equity){\n        if (p.value > peak) peak = p.value;\n        const dd = peak > 0 ? (peak - p.value) / peak : 0;\n        if (dd > maxDD) maxDD = dd;\n    }\n    return {\n        pnlPct,\n        sharpe,\n        winRate,\n        maxDD: maxDD * 100\n    };\n}\nfunction sma(values, period) {\n    const out = [];\n    let sum = 0;\n    for(let i = 0; i < values.length; i++){\n        sum += values[i];\n        if (i >= period) sum -= values[i - period];\n        out.push(i >= period - 1 ? sum / period : NaN);\n    }\n    return out;\n}\nfunction rsi(values) {\n    let period = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 14;\n    const out = [];\n    let avgGain = 0;\n    let avgLoss = 0;\n    for(let i = 1; i < values.length; i++){\n        const change = values[i] - values[i - 1];\n        const gain = Math.max(0, change);\n        const loss = Math.max(0, -change);\n        if (i <= period) {\n            avgGain += gain;\n            avgLoss += loss;\n            out.push(NaN);\n            if (i === period) {\n                avgGain /= period;\n                avgLoss /= period;\n                const rs = avgLoss === 0 ? 100 : avgGain / (avgLoss || 1e-12);\n                out[i - 1] = 100 - 100 / (1 + rs);\n            }\n            continue;\n        }\n        avgGain = (avgGain * (period - 1) + gain) / period;\n        avgLoss = (avgLoss * (period - 1) + loss) / period;\n        const rs = avgLoss === 0 ? 100 : avgGain / (avgLoss || 1e-12);\n        out.push(100 - 100 / (1 + rs));\n    }\n    out.unshift(NaN) // align length to values\n    ;\n    return out;\n}\nfunction computeStrategyEquity(candles, kind) {\n    if (candles.length === 0) return [];\n    const closes = candles.map((c)=>c.close);\n    let inPos = false;\n    let equity = 1;\n    const out = [];\n    const push = (i)=>out.push({\n            time: candles[i].time,\n            value: equity\n        });\n    if (kind === \"SMA Cross\") {\n        const fast = sma(closes, 20);\n        const slow = sma(closes, 50);\n        for(let i = 1; i < candles.length; i++){\n            const enter = !inPos && fast[i] > slow[i] && !isNaN(fast[i]) && !isNaN(slow[i]);\n            const exit = inPos && fast[i] < slow[i];\n            if (enter) inPos = true;\n            if (exit) inPos = false;\n            const ret = (closes[i] - closes[i - 1]) / closes[i - 1];\n            if (inPos) equity *= 1 + ret;\n            push(i);\n        }\n    } else if (kind === \"RSI Mean Reversion\") {\n        const r = rsi(closes, 14);\n        for(let i = 1; i < candles.length; i++){\n            const enter = !inPos && r[i] < 30;\n            const exit = inPos && r[i] > 55;\n            if (enter) inPos = true;\n            if (exit) inPos = false;\n            const ret = (closes[i] - closes[i - 1]) / closes[i - 1];\n            if (inPos) equity *= 1 + ret;\n            push(i);\n        }\n    } else if (kind === \"Breakout\") {\n        const lookback = 20;\n        for(let i = 1; i < candles.length; i++){\n            const start = Math.max(0, i - lookback);\n            const windowHigh = Math.max(...closes.slice(start, i));\n            const windowLow = Math.min(...closes.slice(start, i));\n            const enter = !inPos && closes[i] > windowHigh;\n            const exit = inPos && closes[i] < windowLow;\n            if (enter) inPos = true;\n            if (exit) inPos = false;\n            const ret = (closes[i] - closes[i - 1]) / closes[i - 1];\n            if (inPos) equity *= 1 + ret;\n            push(i);\n        }\n    }\n    if (out.length === 0) return computeEquity(candles);\n    return out;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi90cmFkaW5nLXV0aWxzLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUlBLDZFQUE2RTtBQUN0RSxTQUFTQSxjQUFjQyxPQUFpQjtJQUM3QyxJQUFJLENBQUNBLFFBQVFDLE1BQU0sRUFBRSxPQUFPLEVBQUU7SUFDOUIsTUFBTUMsUUFBUUYsT0FBTyxDQUFDLEVBQUUsQ0FBQ0csS0FBSztJQUM5QixJQUFJQyxTQUFTO0lBQ2IsTUFBTUMsTUFBcUIsRUFBRTtJQUM3QixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSU4sUUFBUUMsTUFBTSxFQUFFSyxJQUFLO1FBQ3ZDLE1BQU1DLE1BQU1ELE1BQU0sSUFBSSxJQUFJLENBQUNOLE9BQU8sQ0FBQ00sRUFBRSxDQUFDSCxLQUFLLEdBQUdILE9BQU8sQ0FBQ00sSUFBSSxFQUFFLENBQUNILEtBQUssSUFBSUgsT0FBTyxDQUFDTSxJQUFJLEVBQUUsQ0FBQ0gsS0FBSztRQUMxRkMsVUFBVSxJQUFJRztRQUNkRixJQUFJRyxJQUFJLENBQUM7WUFBRUMsTUFBTVQsT0FBTyxDQUFDTSxFQUFFLENBQUNHLElBQUk7WUFBRUMsT0FBT047UUFBTztJQUNsRDtJQUNBLE9BQU9DO0FBQ1Q7QUFFTyxTQUFTTSxhQUFhWCxPQUFpQixFQUFFSSxNQUFxQjtJQUNuRSxJQUFJLENBQUNKLFFBQVFDLE1BQU0sSUFBSSxDQUFDRyxPQUFPSCxNQUFNLEVBQUUsT0FBTztRQUFFVyxRQUFRO1FBQUdDLFFBQVE7UUFBR0MsU0FBUztRQUFHQyxPQUFPO0lBQUU7SUFDM0YsTUFBTUMsT0FBaUIsRUFBRTtJQUN6QixJQUFLLElBQUlWLElBQUksR0FBR0EsSUFBSU4sUUFBUUMsTUFBTSxFQUFFSyxJQUFLO1FBQ3ZDLE1BQU1XLElBQUksQ0FBQ2pCLE9BQU8sQ0FBQ00sRUFBRSxDQUFDSCxLQUFLLEdBQUdILE9BQU8sQ0FBQ00sSUFBSSxFQUFFLENBQUNILEtBQUssSUFBSUgsT0FBTyxDQUFDTSxJQUFJLEVBQUUs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QUlLLE1BQU1MLFFBQVE7WUFDbEIsTUFBTTFDLE1BQU0sQ0FBQ3VDLE1BQU0sQ0FBQ3hDLEVBQUUsR0FBR3dDLE1BQU0sQ0FBQ3hDLElBQUksRUFBRSxJQUFJd0MsTUFBTSxDQUFDeEMsSUFBSSxFQUFFO1lBQ3ZELElBQUkyQyxPQUFPN0MsVUFBVSxJQUFJRztZQUN6QkMsS0FBS0Y7UUFDUDtJQUNGO0lBQ0EsSUFBSUQsSUFBSUosTUFBTSxLQUFLLEdBQUcsT0FBT0YsY0FBY0M7SUFDM0MsT0FBT0s7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvdHJhZGluZy11dGlscy50cz8yM2FkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB0eXBlIENhbmRsZSA9IHsgdGltZTogbnVtYmVyOyBvcGVuOiBudW1iZXI7IGhpZ2g6IG51bWJlcjsgbG93OiBudW1iZXI7IGNsb3NlOiBudW1iZXIgfVxyXG5cclxuZXhwb3J0IHR5cGUgRXF1aXR5UG9pbnQgPSB7IHRpbWU6IG51bWJlcjsgdmFsdWU6IG51bWJlciB9XHJcblxyXG4vLyBWZXJ5IHNpbXBsZSBlcXVpdHkgY3VydmU6IGJ1eS1hbmQtaG9sZCBvbiBjbG9zZXMgKHBsYWNlaG9sZGVyIGZvciBwcmVzZXRzKVxyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUVxdWl0eShjYW5kbGVzOiBDYW5kbGVbXSk6IEVxdWl0eVBvaW50W10ge1xyXG4gIGlmICghY2FuZGxlcy5sZW5ndGgpIHJldHVybiBbXVxyXG4gIGNvbnN0IGZpcnN0ID0gY2FuZGxlc1swXS5jbG9zZVxyXG4gIGxldCBlcXVpdHkgPSAxXHJcbiAgY29uc3Qgb3V0OiBFcXVpdHlQb2ludFtdID0gW11cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbmRsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IHJldCA9IGkgPT09IDAgPyAwIDogKGNhbmRsZXNbaV0uY2xvc2UgLSBjYW5kbGVzW2kgLSAxXS5jbG9zZSkgLyBjYW5kbGVzW2kgLSAxXS5jbG9zZVxyXG4gICAgZXF1aXR5ICo9IDEgKyByZXRcclxuICAgIG91dC5wdXNoKHsgdGltZTogY2FuZGxlc1tpXS50aW1lLCB2YWx1ZTogZXF1aXR5IH0pXHJcbiAgfVxyXG4gIHJldHVybiBvdXRcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVTdGF0cyhjYW5kbGVzOiBDYW5kbGVbXSwgZXF1aXR5OiBFcXVpdHlQb2ludFtdKSB7XHJcbiAgaWYgKCFjYW5kbGVzLmxlbmd0aCB8fCAhZXF1aXR5Lmxlbmd0aCkgcmV0dXJuIHsgcG5sUGN0OiAwLCBzaGFycGU6IDAsIHdpblJhdGU6IDAsIG1heEREOiAwIH1cclxuICBjb25zdCByZXRzOiBudW1iZXJbXSA9IFtdXHJcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBjYW5kbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCByID0gKGNhbmRsZXNbaV0uY2xvc2UgLSBjYW5kbGVzW2kgLSAxXS5jbG9zZSkgLyBjYW5kbGVzW2kgLSAxXS5jbG9zZVxyXG4gICAgcmV0cy5wdXNoKHIpXHJcbiAgfVxyXG4gIGNvbnN0IG1lYW4gPSByZXRzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gcmV0cy5sZW5ndGhcclxuICBjb25zdCBzdGQgPSBNYXRoLnNxcnQocmV0cy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBNYXRoLnBvdyhiIC0gbWVhbiwgMiksIDApIC8gTWF0aC5tYXgoMSwgcmV0cy5sZW5ndGggLSAxKSlcclxuICBjb25zdCBzaGFycGUgPSBzdGQgPiAwID8gKG1lYW4gLyBzdGQpICogTWF0aC5zcXJ0KDI1MikgOiAwXHJcbiAgY29uc3Qgd2luUmF0ZSA9IHJldHMuZmlsdGVyKChyKSA9PiByID4gMCkubGVuZ3RoIC8gcmV0cy5sZW5ndGhcclxuICBjb25zdCBwbmxQY3QgPSAoZXF1aXR5W2VxdWl0eS5sZW5ndGggLSAxXS52YWx1ZSAtIDEpICogMTAwXHJcbiAgLy8gTWF4IGRyYXdkb3duXHJcbiAgbGV0IHBlYWsgPSBlcXVpdHlbMF0udmFsdWVcclxuICBsZXQgbWF4REQgPSAwXHJcbiAgZm9yIChjb25zdCBwIG9mIGVxdWl0eSkge1xyXG4gICAgaWYgKHAudmFsdWUgPiBwZWFrKSBwZWFrID0gcC52YWx1ZVxyXG4gICAgY29uc3QgZGQgPSBwZWFrID4gMCA/IChwZWFrIC0gcC52YWx1ZSkgLyBwZWFrIDogMFxyXG4gICAgaWYgKGRkID4gbWF4REQpIG1heEREID0gZGRcclxuICB9XHJcbiAgcmV0dXJuIHsgcG5sUGN0LCBzaGFycGUsIHdpblJhdGUsIG1heEREOiBtYXhERCAqIDEwMCB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNtYSh2YWx1ZXM6IG51bWJlcltdLCBwZXJpb2Q6IG51bWJlcik6IG51bWJlcltdIHtcclxuICBjb25zdCBvdXQ6IG51bWJlcltdID0gW11cclxuICBsZXQgc3VtID0gMFxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBzdW0gKz0gdmFsdWVzW2ldXHJcbiAgICBpZiAoaSA+PSBwZXJpb2QpIHN1bSAtPSB2YWx1ZXNbaSAtIHBlcmlvZF1cclxuICAgIG91dC5wdXNoKGkgPj0gcGVyaW9kIC0gMSA/IHN1bSAvIHBlcmlvZCA6IE5hTilcclxuICB9XHJcbiAgcmV0dXJuIG91dFxyXG59XHJcblxyXG5mdW5jdGlvbiByc2kodmFsdWVzOiBudW1iZXJbXSwgcGVyaW9kID0gMTQpOiBudW1iZXJbXSB7XHJcbiAgY29uc3Qgb3V0OiBudW1iZXJbXSA9IFtdXHJcbiAgbGV0IGF2Z0dhaW4gPSAwXHJcbiAgbGV0IGF2Z0xvc3MgPSAwXHJcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGNoYW5nZSA9IHZhbHVlc1tpXSAtIHZhbHVlc1tpIC0gMV1cclxuICAgIGNvbnN0IGdhaW4gPSBNYXRoLm1heCgwLCBjaGFuZ2UpXHJcbiAgICBjb25zdCBsb3NzID0gTWF0aC5tYXgoMCwgLWNoYW5nZSlcclxuICAgIGlmIChpIDw9IHBlcmlvZCkge1xyXG4gICAgICBhdmdHYWluICs9IGdhaW5cclxuICAgICAgYXZnTG9zcyArPSBsb3NzXHJcbiAgICAgIG91dC5wdXNoKE5hTilcclxuICAgICAgaWYgKGkgPT09IHBlcmlvZCkge1xyXG4gICAgICAgIGF2Z0dhaW4gLz0gcGVyaW9kXHJcbiAgICAgICAgYXZnTG9zcyAvPSBwZXJpb2RcclxuICAgICAgICBjb25zdCBycyA9IGF2Z0xvc3MgPT09IDAgPyAxMDAgOiBhdmdHYWluIC8gKGF2Z0xvc3MgfHwgMWUtMTIpXHJcbiAgICAgICAgb3V0W2kgLSAxXSA9IDEwMCAtIDEwMCAvICgxICsgcnMpXHJcbiAgICAgIH1cclxuICAgICAgY29udGludWVcclxuICAgIH1cclxuICAgIGF2Z0dhaW4gPSAoYXZnR2FpbiAqIChwZXJpb2QgLSAxKSArIGdhaW4pIC8gcGVyaW9kXHJcbiAgICBhdmdMb3NzID0gKGF2Z0xvc3MgKiAocGVyaW9kIC0gMSkgKyBsb3NzKSAvIHBlcmlvZFxyXG4gICAgY29uc3QgcnMgPSBhdmdMb3NzID09PSAwID8gMTAwIDogYXZnR2FpbiAvIChhdmdMb3NzIHx8IDFlLTEyKVxyXG4gICAgb3V0LnB1c2goMTAwIC0gMTAwIC8gKDEgKyBycykpXHJcbiAgfVxyXG4gIG91dC51bnNoaWZ0KE5hTikgLy8gYWxpZ24gbGVuZ3RoIHRvIHZhbHVlc1xyXG4gIHJldHVybiBvdXRcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgU3RyYXRlZ3lLaW5kID0gJ1NNQSBDcm9zcycgfCAnQnJlYWtvdXQnIHwgJ1JTSSBNZWFuIFJldmVyc2lvbidcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlU3RyYXRlZ3lFcXVpdHkoY2FuZGxlczogQ2FuZGxlW10sIGtpbmQ6IFN0cmF0ZWd5S2luZCk6IEVxdWl0eVBvaW50W10ge1xyXG4gIGlmIChjYW5kbGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdXHJcbiAgY29uc3QgY2xvc2VzID0gY2FuZGxlcy5tYXAoKGMpID0+IGMuY2xvc2UpXHJcbiAgbGV0IGluUG9zID0gZmFsc2VcclxuICBsZXQgZXF1aXR5ID0gMVxyXG4gIGNvbnN0IG91dDogRXF1aXR5UG9pbnRbXSA9IFtdXHJcbiAgY29uc3QgcHVzaCA9IChpOiBudW1iZXIpID0+IG91dC5wdXNoKHsgdGltZTogY2FuZGxlc1tpXS50aW1lLCB2YWx1ZTogZXF1aXR5IH0pXHJcblxyXG4gIGlmIChraW5kID09PSAnU01BIENyb3NzJykge1xyXG4gICAgY29uc3QgZmFzdCA9IHNtYShjbG9zZXMsIDIwKVxyXG4gICAgY29uc3Qgc2xvdyA9IHNtYShjbG9zZXMsIDUwKVxyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjYW5kbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGVudGVyID0gIWluUG9zICYmIGZhc3RbaV0gPiBzbG93W2ldICYmICFpc05hTihmYXN0W2ldKSAmJiAhaXNOYU4oc2xvd1tpXSlcclxuICAgICAgY29uc3QgZXhpdCA9IGluUG9zICYmIGZhc3RbaV0gPCBzbG93W2ldXHJcbiAgICAgIGlmIChlbnRlcikgaW5Qb3MgPSB0cnVlXHJcbiAgICAgIGlmIChleGl0KSBpblBvcyA9IGZhbHNlXHJcbiAgICAgIGNvbnN0IHJldCA9IChjbG9zZXNbaV0gLSBjbG9zZXNbaSAtIDFdKSAvIGNsb3Nlc1tpIC0gMV1cclxuICAgICAgaWYgKGluUG9zKSBlcXVpdHkgKj0gMSArIHJldFxyXG4gICAgICBwdXNoKGkpXHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChraW5kID09PSAnUlNJIE1lYW4gUmV2ZXJzaW9uJykge1xyXG4gICAgY29uc3QgciA9IHJzaShjbG9zZXMsIDE0KVxyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjYW5kbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGVudGVyID0gIWluUG9zICYmIHJbaV0gPCAzMFxyXG4gICAgICBjb25zdCBleGl0ID0gaW5Qb3MgJiYgcltpXSA+IDU1XHJcbiAgICAgIGlmIChlbnRlcikgaW5Qb3MgPSB0cnVlXHJcbiAgICAgIGlmIChleGl0KSBpblBvcyA9IGZhbHNlXHJcbiAgICAgIGNvbnN0IHJldCA9IChjbG9zZXNbaV0gLSBjbG9zZXNbaSAtIDFdKSAvIGNsb3Nlc1tpIC0gMV1cclxuICAgICAgaWYgKGluUG9zKSBlcXVpdHkgKj0gMSArIHJldFxyXG4gICAgICBwdXNoKGkpXHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChraW5kID09PSAnQnJlYWtvdXQnKSB7XHJcbiAgICBjb25zdCBsb29rYmFjayA9IDIwXHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNhbmRsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBpIC0gbG9va2JhY2spXHJcbiAgICAgIGNvbnN0IHdpbmRvd0hpZ2ggPSBNYXRoLm1heCguLi5jbG9zZXMuc2xpY2Uoc3RhcnQsIGkpKVxyXG4gICAgICBjb25zdCB3aW5kb3dMb3cgPSBNYXRoLm1pbiguLi5jbG9zZXMuc2xpY2Uoc3RhcnQsIGkpKVxyXG4gICAgICBjb25zdCBlbnRlciA9ICFpblBvcyAmJiBjbG9zZXNbaV0gPiB3aW5kb3dIaWdoXHJcbiAgICAgIGNvbnN0IGV4aXQgPSBpblBvcyAmJiBjbG9zZXNbaV0gPCB3aW5kb3dMb3dcclxuICAgICAgaWYgKGVudGVyKSBpblBvcyA9IHRydWVcclxuICAgICAgaWYgKGV4aXQpIGluUG9zID0gZmFsc2VcclxuICAgICAgY29uc3QgcmV0ID0gKGNsb3Nlc1tpXSAtIGNsb3Nlc1tpIC0gMV0pIC8gY2xvc2VzW2kgLSAxXVxyXG4gICAgICBpZiAoaW5Qb3MpIGVxdWl0eSAqPSAxICsgcmV0XHJcbiAgICAgIHB1c2goaSlcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKG91dC5sZW5ndGggPT09IDApIHJldHVybiBjb21wdXRlRXF1aXR5KGNhbmRsZXMpXHJcbiAgcmV0dXJuIG91dFxyXG59XHJcblxyXG5cclxuXHJcbiJdLCJuYW1lcyI6WyJjb21wdXRlRXF1aXR5IiwiY2FuZGxlcyIsImxlbmd0aCIsImZpcnN0IiwiY2xvc2UiLCJlcXVpdHkiLCJvdXQiLCJpIiwicmV0IiwicHVzaCIsInRpbWUiLCJ2YWx1ZSIsImNvbXB1dGVTdGF0cyIsInBubFBjdCIsInNoYXJwZSIsIndpblJhdGUiLCJtYXhERCIsInJldHMiLCJyIiwibWVhbiIsInJlZHVjZSIsImEiLCJiIiwic3RkIiwiTWF0aCIsInNxcnQiLCJwb3ciLCJtYXgiLCJmaWx0ZXIiLCJwZWFrIiwicCIsImRkIiwic21hIiwidmFsdWVzIiwicGVyaW9kIiwic3VtIiwiTmFOIiwicnNpIiwiYXZnR2FpbiIsImF2Z0xvc3MiLCJjaGFuZ2UiLCJnYWluIiwibG9zcyIsInJzIiwidW5zaGlmdCIsImNvbXB1dGVTdHJhdGVneUVxdWl0eSIsImtpbmQiLCJjbG9zZXMiLCJtYXAiLCJjIiwiaW5Qb3MiLCJmYXN0Iiwic2xvdyIsImVudGVyIiwiaXNOYU4iLCJleGl0IiwibG9va2JhY2siLCJzdGFydCIsIndpbmRvd0hpZ2giLCJzbGljZSIsIndpbmRvd0xvdyIsIm1pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/trading-utils.ts\n"));

/***/ })

});